field_mod.f90:  type, public :: field_type
field_mod.f90:  end type field_type
field_mod.f90:  type, public, extends(field_type) :: r2d_field
field_mod.f90:    class(field_type), intent(inout) :: fld
field_mod.f90:    class(field_type), intent(inout) :: fld
field_mod.f90:    class(field_type), intent(inout) :: fld
field_mod.f90:    class(field_type), intent(inout) :: fld
field_mod.f90:    class(field_type), intent(inout) :: fld
field_mod.f90:    class(field_type), intent(inout) :: fld
field_mod.f90:    class(field_type), intent(inout) :: fld
field_mod.f90:    class(field_type), intent(inout) :: fld
field_mod.f90:    class(field_type), intent(inout) :: fld
field_mod.f90:    class(field_type), intent(inout) :: fld
field_mod.f90:    class(field_type), intent(inout) :: fld
field_mod.f90:    class(field_type), intent(inout) :: fld
field_mod.f90:    class(field_type), intent(inout) :: fld
field_mod.f90:    class(field_type), intent(inout) :: fld
field_mod.f90:    class(field_type), INTENT(out) :: fld
field_mod.f90:    class(field_type), intent(inout) :: fld
gnu_opt_report.txt: scalar_type: struct field_type
gnu_opt_report.txt:field_mod.f90:1362:0: note: not vectorized: no vectype for stmt: *dst_11(D).field_type = *src_12(D).field_type;
gnu_opt_report.txt: scalar_type: struct field_type
gnu_opt_report.txt:field_mod.f90:1362:0: note: not vectorized: more than one data ref in stmt: *dst_11(D).field_type = *src_12(D).field_type;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _2 = *src_12(D).field_type.halo.dim[0].ubound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _3 = *src_12(D).field_type.halo.dim[0].lbound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: Detected interleaving load *src_12(D).field_type.halo.dim[0].lbound and *src_12(D).field_type.halo.dim[0].ubound
gnu_opt_report.txt:field_mod.f90:1362:0: note: Detected interleaving load of size 2 starting with _3 = *src_12(D).field_type.halo.dim[0].lbound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: *dst_11(D).field_type.halo.data = _18;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: *dst_11(D).field_type.halo.data = 0B;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _87 = MEM[(struct array15_field_type *)array_39(D)].dim[_84].ubound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _88 = MEM[(struct array15_field_type *)array_39(D)].dim[_84].lbound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: Detected interleaving load MEM[(struct array15_field_type *)array_39(D)].dim[_84].lbound and MEM[(struct array15_field_type *)array_39(D)].dim[_84].ubound
gnu_opt_report.txt:field_mod.f90:1362:0: note: Detected interleaving load of size 3 starting with _88 = MEM[(struct array15_field_type *)array_39(D)].dim[_84].lbound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: init: stmt relevant? _87 = MEM[(struct array15_field_type *)array_39(D)].dim[_84].ubound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: init: stmt relevant? _88 = MEM[(struct array15_field_type *)array_39(D)].dim[_84].lbound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: def_stmt: _87 = MEM[(struct array15_field_type *)array_39(D)].dim[_84].ubound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: mark relevant 5, live 0: _87 = MEM[(struct array15_field_type *)array_39(D)].dim[_84].ubound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: def_stmt: _88 = MEM[(struct array15_field_type *)array_39(D)].dim[_84].lbound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: mark relevant 5, live 0: _88 = MEM[(struct array15_field_type *)array_39(D)].dim[_84].lbound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: worklist: examine stmt: _88 = MEM[(struct array15_field_type *)array_39(D)].dim[_84].lbound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: worklist: examine stmt: _87 = MEM[(struct array15_field_type *)array_39(D)].dim[_84].ubound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _268 = MEM[(struct array15_field_type &)array_39(D)].dim[_269].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: Detected single element interleaving MEM[(struct array15_field_type &)array_39(D)].dim[_269].stride step 24
gnu_opt_report.txt:field_mod.f90:1362:0: note: init: stmt relevant? _268 = MEM[(struct array15_field_type &)array_39(D)].dim[_269].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: def_stmt: _268 = MEM[(struct array15_field_type &)array_39(D)].dim[_269].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: mark relevant 5, live 0: _268 = MEM[(struct array15_field_type &)array_39(D)].dim[_269].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: worklist: examine stmt: _268 = MEM[(struct array15_field_type &)array_39(D)].dim[_269].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: ==> examining statement: _268 = MEM[(struct array15_field_type &)array_39(D)].dim[_269].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note:   based on:     _268 = MEM[(struct array15_field_type &)array_39(D)].dim[_269].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: can't force alignment of ref: MEM[(struct array15_field_type &)array_39(D)].dim[_269].stride
gnu_opt_report.txt:field_mod.f90:1362:0: note: ==> examining statement: _268 = MEM[(struct array15_field_type &)array_39(D)].dim[_269].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: vect_is_simple_use: operand MEM[(struct array15_field_type &)array_39(D)].dim[_269].stride
gnu_opt_report.txt:field_mod.f90:1362:0: note: vect_is_simple_use: operand MEM[(struct array15_field_type &)array_39(D)].dim[_269].stride
gnu_opt_report.txt:field_mod.f90:1362:0: note: def_stmt: _268 = MEM[(struct array15_field_type &)array_39(D)].dim[_269].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: pretmp_256 = MEM[(struct array15_field_type &)array_39(D)].dtype.rank;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access pretmp_256 = MEM[(struct array15_field_type &)array_39(D)].dtype.rank;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _245 = MEM[(struct array15_field_type &)array_39(D)].dim[_207].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _245 = MEM[(struct array15_field_type &)array_39(D)].dim[_207].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _186 = MEM[(struct array15_field_type &)array_39(D)].dim[_187].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _186 = MEM[(struct array15_field_type &)array_39(D)].dim[_187].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _180 = MEM[(struct array15_field_type &)array_39(D)].dim[_181].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _180 = MEM[(struct array15_field_type &)array_39(D)].dim[_181].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _174 = MEM[(struct array15_field_type &)array_39(D)].dim[_175].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _174 = MEM[(struct array15_field_type &)array_39(D)].dim[_175].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _168 = MEM[(struct array15_field_type &)array_39(D)].dim[_169].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _168 = MEM[(struct array15_field_type &)array_39(D)].dim[_169].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _162 = MEM[(struct array15_field_type &)array_39(D)].dim[_163].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _162 = MEM[(struct array15_field_type &)array_39(D)].dim[_163].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _156 = MEM[(struct array15_field_type &)array_39(D)].dim[_157].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _156 = MEM[(struct array15_field_type &)array_39(D)].dim[_157].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _148 = MEM[(struct array15_field_type &)array_39(D)].dim[_149].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _148 = MEM[(struct array15_field_type &)array_39(D)].dim[_149].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _118 = MEM[(struct array15_field_type &)array_39(D)].dim[_136].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _118 = MEM[(struct array15_field_type &)array_39(D)].dim[_136].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _34 = MEM[(struct array15_field_type &)array_39(D)].dim[_83].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _34 = MEM[(struct array15_field_type &)array_39(D)].dim[_83].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _28 = MEM[(struct array15_field_type &)array_39(D)].dim[_29].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _28 = MEM[(struct array15_field_type &)array_39(D)].dim[_29].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _296 = MEM[(struct array15_field_type &)array_39(D)].dim[_297].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _296 = MEM[(struct array15_field_type &)array_39(D)].dim[_297].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _281 = MEM[(struct array15_field_type &)array_39(D)].dim[_283].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _281 = MEM[(struct array15_field_type &)array_39(D)].dim[_283].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _240 = MEM[(struct array15_field_type &)array_39(D)].dim[_246].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _240 = MEM[(struct array15_field_type &)array_39(D)].dim[_246].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _58 = MEM[(struct array15_field_type &)array_39(D)].dim[_15].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _58 = MEM[(struct array15_field_type &)array_39(D)].dim[_15].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _75 = MEM[(struct array15_field_type &)array_39(D)].dim[_74].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _75 = MEM[(struct array15_field_type &)array_39(D)].dim[_74].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _268 = MEM[(struct array15_field_type &)array_39(D)].dim[_269].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _268 = MEM[(struct array15_field_type &)array_39(D)].dim[_269].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _87 = MEM[(struct array15_field_type *)array_39(D)].dim[_84].ubound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _88 = MEM[(struct array15_field_type *)array_39(D)].dim[_84].lbound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: Detected interleaving load MEM[(struct array15_field_type *)array_39(D)].dim[_84].lbound and MEM[(struct array15_field_type *)array_39(D)].dim[_84].ubound
gnu_opt_report.txt:field_mod.f90:1362:0: note: Detected interleaving load of size 2 starting with _88 = MEM[(struct array15_field_type *)array_39(D)].dim[_84].lbound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _111 = MEM[(struct array15_field_type &)array_39(D)].data;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: pretmp_294 = MEM[(struct array15_field_type &)array_39(D)].dtype.rank;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: pretmp_257 = MEM[(struct array15_field_type &)array_39(D)].dtype.rank;
gnu_opt_report.txt:field_mod.f90:243:0: note: got vectype for stmt: self.field_type.halo.data = 0B;
gnu_opt_report.txt:field_mod.f90:243:0: note: got vectype for stmt: self.field_type.grid = grid_58(D);
gnu_opt_report.txt:field_mod.f90:243:0: note: got vectype for stmt: self.field_type.data_on_device = 0;
gnu_opt_report.txt:field_mod.f90:243:0: note: not consecutive access self.field_type.data_on_device = 0;
gnu_opt_report.txt:field_mod.f90:243:0: note: not consecutive access self.field_type.grid = grid_58(D);
gnu_opt_report.txt:field_mod.f90:243:0: note: not consecutive access self.field_type.halo.data = 0B;
gnu_opt_report.txt:field_mod.f90:317:0: note: got vectype for stmt: MEM[(struct field_type *)&self].defined_on = 0;
gnu_opt_report.txt:field_mod.f90:317:0: note: not consecutive access MEM[(struct field_type *)&self].defined_on = 0;
gnu_opt_report.txt:field_mod.f90:969:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstart = pretmp_1875;
gnu_opt_report.txt:field_mod.f90:969:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstop = pretmp_1876;
gnu_opt_report.txt:field_mod.f90:969:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystart = pretmp_1877;
gnu_opt_report.txt:field_mod.f90:969:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystop = pretmp_1878;
gnu_opt_report.txt:field_mod.f90:969:0: note: got vectype for stmt: MEM[(struct field_type *)&self].num_halos = 2;
gnu_opt_report.txt:field_mod.f90:969:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:969:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystart
gnu_opt_report.txt:field_mod.f90:969:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:969:0: note: Detected interleaving store of size 4 starting with MEM[(struct field_type *)&self].internal.xstart = pretmp_1875;
gnu_opt_report.txt:field_mod.f90:969:0: note: not consecutive access MEM[(struct field_type *)&self].num_halos = 2;
gnu_opt_report.txt:field_mod.f90:969:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstart = pretmp_1875;
gnu_opt_report.txt:field_mod.f90:969:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstop = pretmp_1876;
gnu_opt_report.txt:field_mod.f90:969:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystart = pretmp_1877;
gnu_opt_report.txt:field_mod.f90:969:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystop = pretmp_1878;
gnu_opt_report.txt:field_mod.f90:969:0: note: 	stmt 0 MEM[(struct field_type *)&self].internal.xstart = pretmp_1875;
gnu_opt_report.txt:field_mod.f90:969:0: note: 	stmt 1 MEM[(struct field_type *)&self].internal.xstop = pretmp_1876;
gnu_opt_report.txt:field_mod.f90:969:0: note: 	stmt 2 MEM[(struct field_type *)&self].internal.ystart = pretmp_1877;
gnu_opt_report.txt:field_mod.f90:969:0: note: 	stmt 3 MEM[(struct field_type *)&self].internal.ystop = pretmp_1878;
gnu_opt_report.txt:field_mod.f90:969:0: note:   based on:     MEM[(struct field_type *)&self].internal.xstart = pretmp_1875;
gnu_opt_report.txt:field_mod.f90:969:0: note: misalign = 8 bytes of ref MEM[(struct field_type *)&self].internal.xstart
gnu_opt_report.txt:field_mod.f90:969:0: note: ==> examining statement: MEM[(struct field_type *)&self].internal.xstart = pretmp_1875;
gnu_opt_report.txt:field_mod.f90:969:0: note: ------>vectorizing SLP node starting from: MEM[(struct field_type *)&self].internal.xstart = pretmp_1875;
gnu_opt_report.txt:field_mod.f90:969:0: note: create vector_type-pointer variable to type: vector(4) integer(kind=4)  vectorizing a pointer ref: MEM[(struct field_type *)&self].internal.xstart
gnu_opt_report.txt:field_mod.f90:969:0: note: created &MEM[(struct field_type *)&self].internal.xstart
gnu_opt_report.txt:field_mod.f90:967:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstart = _366;
gnu_opt_report.txt:field_mod.f90:967:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstop = pretmp_1876;
gnu_opt_report.txt:field_mod.f90:967:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystart = pretmp_1877;
gnu_opt_report.txt:field_mod.f90:967:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystop = pretmp_1878;
gnu_opt_report.txt:field_mod.f90:967:0: note: got vectype for stmt: MEM[(struct field_type *)&self].num_halos = 0;
gnu_opt_report.txt:field_mod.f90:967:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:967:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystart
gnu_opt_report.txt:field_mod.f90:967:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:967:0: note: Detected interleaving store of size 4 starting with MEM[(struct field_type *)&self].internal.xstart = _366;
gnu_opt_report.txt:field_mod.f90:967:0: note: not consecutive access MEM[(struct field_type *)&self].num_halos = 0;
gnu_opt_report.txt:field_mod.f90:967:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstart = _366;
gnu_opt_report.txt:field_mod.f90:967:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstop = pretmp_1876;
gnu_opt_report.txt:field_mod.f90:967:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystart = pretmp_1877;
gnu_opt_report.txt:field_mod.f90:967:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystop = pretmp_1878;
gnu_opt_report.txt:field_mod.f90:967:0: note:   based on:     MEM[(struct field_type *)&self].internal.xstart = _366;
gnu_opt_report.txt:field_mod.f90:972:0: note: got vectype for stmt: MEM[(struct field_type *)&self].num_halos = prephitmp_1880;
gnu_opt_report.txt:field_mod.f90:975:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dtype.elem_len = 52;
gnu_opt_report.txt:field_mod.f90:975:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dtype.rank = 1;
gnu_opt_report.txt:field_mod.f90:975:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dtype.type = 5;
gnu_opt_report.txt:field_mod.f90:975:0: note: Detected interleaving store MEM[(struct field_type *)&self].halo.dtype.rank and MEM[(struct field_type *)&self].halo.dtype.type
gnu_opt_report.txt:field_mod.f90:975:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].halo.dtype.rank = 1;
gnu_opt_report.txt:field_mod.f90:975:0: note: not consecutive access MEM[(struct field_type *)&self].halo.dtype.elem_len = 52;
gnu_opt_report.txt:field_mod.f90:975:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dtype.rank = 1;
gnu_opt_report.txt:field_mod.f90:975:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.data = _387;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dim[0].lbound = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dim[0].ubound = _392;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dim[0].stride = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.offset = -1;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving store MEM[(struct field_type *)&self].halo.span and MEM[(struct field_type *)&self].halo.dim[0].stride
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving store MEM[(struct field_type *)&self].halo.span and MEM[(struct field_type *)&self].halo.dim[0].lbound
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving store MEM[(struct field_type *)&self].halo.span and MEM[(struct field_type *)&self].halo.dim[0].ubound
gnu_opt_report.txt:field_mod.f90:978:0: note: not consecutive access MEM[(struct field_type *)&self].halo.offset = -1;
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving store of size 4 starting with MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dim[0].stride = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dim[0].lbound = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dim[0].ubound = _392;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP failed: different operation in stmt MEM[(struct field_type *)&self].halo.dim[0].ubound = _392;
gnu_opt_report.txt:field_mod.f90:978:0: note: original stmt MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dim[0].stride = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: 	stmt 0 MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: 	stmt 1 MEM[(struct field_type *)&self].halo.dim[0].stride = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note:   based on:     MEM[(struct field_type *)&self].halo.dim[0].lbound = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: misalign = 8 bytes of ref MEM[(struct field_type *)&self].halo.span
gnu_opt_report.txt:field_mod.f90:978:0: note: ==> examining statement: MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: ------>vectorizing SLP node starting from: MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: create vector_type-pointer variable to type: vector(2) integer(kind=8)  vectorizing a pointer ref: MEM[(struct field_type *)&self].halo.span
gnu_opt_report.txt:field_mod.f90:978:0: note: created &MEM[(struct field_type *)&self].halo.span
gnu_opt_report.txt:field_mod.f90:1004:0: note: got vectype for stmt: pretmp_1543 = MEM[(struct field_type *)&self].internal.ystop;
gnu_opt_report.txt:field_mod.f90:1004:0: note: got vectype for stmt: pretmp_1557 = MEM[(struct field_type *)&self].internal.ystart;
gnu_opt_report.txt:field_mod.f90:1004:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.ystart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:1004:0: note: Detected interleaving load of size 2 starting with pretmp_1557 = MEM[(struct field_type *)&self].internal.ystart;
gnu_opt_report.txt:field_mod.f90:1027:0: note: got vectype for stmt: pretmp_1544 = MEM[(struct field_type *)&self].internal.ystop;
gnu_opt_report.txt:field_mod.f90:1027:0: note: got vectype for stmt: pretmp_1558 = MEM[(struct field_type *)&self].internal.ystart;
gnu_opt_report.txt:field_mod.f90:1027:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.ystart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:1027:0: note: Detected interleaving load of size 2 starting with pretmp_1558 = MEM[(struct field_type *)&self].internal.ystart;
gnu_opt_report.txt:field_mod.f90:1027:0: note:   based on:     pretmp_1544 = MEM[(struct field_type *)&self].internal.ystop;
gnu_opt_report.txt:field_mod.f90:455:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstart = _417;
gnu_opt_report.txt:field_mod.f90:455:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstop = _419;
gnu_opt_report.txt:field_mod.f90:455:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:455:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].internal.xstart = _417;
gnu_opt_report.txt:field_mod.f90:455:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstart = _417;
gnu_opt_report.txt:field_mod.f90:455:0: note:   based on:     MEM[(struct field_type *)&self].internal.xstart = _417;
gnu_opt_report.txt:field_mod.f90:461:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystart = _423;
gnu_opt_report.txt:field_mod.f90:461:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystop = _424;
gnu_opt_report.txt:field_mod.f90:461:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.ystart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:461:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].internal.ystart = _423;
gnu_opt_report.txt:field_mod.f90:461:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystart = _423;
gnu_opt_report.txt:field_mod.f90:461:0: note:   based on:     MEM[(struct field_type *)&self].internal.ystart = _423;
gnu_opt_report.txt:field_mod.f90:463:0: note: got vectype for stmt: pretmp_1868 = MEM[(struct field_type *)&self].internal.ystop;
gnu_opt_report.txt:field_mod.f90:463:0: note: got vectype for stmt: pretmp_1870 = MEM[(struct field_type *)&self].internal.ystart;
gnu_opt_report.txt:field_mod.f90:463:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.ystart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:463:0: note: Detected interleaving load of size 2 starting with pretmp_1870 = MEM[(struct field_type *)&self].internal.ystart;
gnu_opt_report.txt:field_mod.f90:467:0: note: got vectype for stmt: MEM[(struct field_type *)&self].num_halos = 0;
gnu_opt_report.txt:field_mod.f90:467:0: note: got vectype for stmt: pretmp_1506 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:467:0: note: got vectype for stmt: pretmp_1520 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:467:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:467:0: note: Detected interleaving load of size 2 starting with pretmp_1520 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:467:0: note: not consecutive access MEM[(struct field_type *)&self].num_halos = 0;
gnu_opt_report.txt:field_mod.f90:317:0: note: got vectype for stmt: pretmp_1517 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:317:0: note: got vectype for stmt: pretmp_1531 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:317:0: note: got vectype for stmt: pretmp_1545 = MEM[(struct field_type *)&self].internal.ystop;
gnu_opt_report.txt:field_mod.f90:317:0: note: got vectype for stmt: pretmp_1559 = MEM[(struct field_type *)&self].internal.ystart;
gnu_opt_report.txt:field_mod.f90:317:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:317:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystart
gnu_opt_report.txt:field_mod.f90:317:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:317:0: note: Detected interleaving load of size 4 starting with pretmp_1531 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:488:0: note: got vectype for stmt: MEM[(struct field_type *)&self].defined_on = 1;
gnu_opt_report.txt:field_mod.f90:488:0: note: not consecutive access MEM[(struct field_type *)&self].defined_on = 1;
gnu_opt_report.txt:field_mod.f90:509:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstart = pretmp_1826;
gnu_opt_report.txt:field_mod.f90:509:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstop = pretmp_1827;
gnu_opt_report.txt:field_mod.f90:509:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystart = pretmp_1824;
gnu_opt_report.txt:field_mod.f90:509:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystop = pretmp_1825;
gnu_opt_report.txt:field_mod.f90:509:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:509:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystart
gnu_opt_report.txt:field_mod.f90:509:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:509:0: note: Detected interleaving store of size 4 starting with MEM[(struct field_type *)&self].internal.xstart = pretmp_1826;
gnu_opt_report.txt:field_mod.f90:509:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstart = pretmp_1826;
gnu_opt_report.txt:field_mod.f90:509:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstop = pretmp_1827;
gnu_opt_report.txt:field_mod.f90:509:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystart = pretmp_1824;
gnu_opt_report.txt:field_mod.f90:509:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystop = pretmp_1825;
gnu_opt_report.txt:field_mod.f90:509:0: note: 	stmt 0 MEM[(struct field_type *)&self].internal.xstart = pretmp_1826;
gnu_opt_report.txt:field_mod.f90:509:0: note: 	stmt 1 MEM[(struct field_type *)&self].internal.xstop = pretmp_1827;
gnu_opt_report.txt:field_mod.f90:509:0: note: 	stmt 2 MEM[(struct field_type *)&self].internal.ystart = pretmp_1824;
gnu_opt_report.txt:field_mod.f90:509:0: note: 	stmt 3 MEM[(struct field_type *)&self].internal.ystop = pretmp_1825;
gnu_opt_report.txt:field_mod.f90:509:0: note:   based on:     MEM[(struct field_type *)&self].internal.xstart = pretmp_1826;
gnu_opt_report.txt:field_mod.f90:509:0: note: misalign = 8 bytes of ref MEM[(struct field_type *)&self].internal.xstart
gnu_opt_report.txt:field_mod.f90:509:0: note: ==> examining statement: MEM[(struct field_type *)&self].internal.xstart = pretmp_1826;
gnu_opt_report.txt:field_mod.f90:509:0: note: ------>vectorizing SLP node starting from: MEM[(struct field_type *)&self].internal.xstart = pretmp_1826;
gnu_opt_report.txt:field_mod.f90:509:0: note: create vector_type-pointer variable to type: vector(4) integer(kind=4)  vectorizing a pointer ref: MEM[(struct field_type *)&self].internal.xstart
gnu_opt_report.txt:field_mod.f90:509:0: note: created &MEM[(struct field_type *)&self].internal.xstart
gnu_opt_report.txt:field_mod.f90:527:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstart = pretmp_1826;
gnu_opt_report.txt:field_mod.f90:527:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstop = pretmp_1827;
gnu_opt_report.txt:field_mod.f90:527:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystart = _439;
gnu_opt_report.txt:field_mod.f90:527:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystop = pretmp_1825;
gnu_opt_report.txt:field_mod.f90:527:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:527:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystart
gnu_opt_report.txt:field_mod.f90:527:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:527:0: note: Detected interleaving store of size 4 starting with MEM[(struct field_type *)&self].internal.xstart = pretmp_1826;
gnu_opt_report.txt:field_mod.f90:527:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstart = pretmp_1826;
gnu_opt_report.txt:field_mod.f90:527:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstop = pretmp_1827;
gnu_opt_report.txt:field_mod.f90:527:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystart = _439;
gnu_opt_report.txt:field_mod.f90:527:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystop = pretmp_1825;
gnu_opt_report.txt:field_mod.f90:527:0: note:   based on:     MEM[(struct field_type *)&self].internal.xstart = pretmp_1826;
gnu_opt_report.txt:field_mod.f90:968:0: note: got vectype for stmt: MEM[(struct field_type *)&self].num_halos = 0;
gnu_opt_report.txt:field_mod.f90:968:0: note: not consecutive access MEM[(struct field_type *)&self].num_halos = 0;
gnu_opt_report.txt:field_mod.f90:969:0: note: got vectype for stmt: MEM[(struct field_type *)&self].num_halos = 2;
gnu_opt_report.txt:field_mod.f90:972:0: note: got vectype for stmt: MEM[(struct field_type *)&self].num_halos = prephitmp_1835;
gnu_opt_report.txt:field_mod.f90:975:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dtype.elem_len = 52;
gnu_opt_report.txt:field_mod.f90:975:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dtype.rank = 1;
gnu_opt_report.txt:field_mod.f90:975:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dtype.type = 5;
gnu_opt_report.txt:field_mod.f90:975:0: note: Detected interleaving store MEM[(struct field_type *)&self].halo.dtype.rank and MEM[(struct field_type *)&self].halo.dtype.type
gnu_opt_report.txt:field_mod.f90:975:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].halo.dtype.rank = 1;
gnu_opt_report.txt:field_mod.f90:975:0: note: not consecutive access MEM[(struct field_type *)&self].halo.dtype.elem_len = 52;
gnu_opt_report.txt:field_mod.f90:975:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dtype.rank = 1;
gnu_opt_report.txt:field_mod.f90:975:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.data = _458;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dim[0].lbound = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dim[0].ubound = _463;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dim[0].stride = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.offset = -1;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving store MEM[(struct field_type *)&self].halo.span and MEM[(struct field_type *)&self].halo.dim[0].stride
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving store MEM[(struct field_type *)&self].halo.span and MEM[(struct field_type *)&self].halo.dim[0].lbound
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving store MEM[(struct field_type *)&self].halo.span and MEM[(struct field_type *)&self].halo.dim[0].ubound
gnu_opt_report.txt:field_mod.f90:978:0: note: not consecutive access MEM[(struct field_type *)&self].halo.offset = -1;
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving store of size 4 starting with MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dim[0].stride = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dim[0].lbound = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dim[0].ubound = _463;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP failed: different operation in stmt MEM[(struct field_type *)&self].halo.dim[0].ubound = _463;
gnu_opt_report.txt:field_mod.f90:978:0: note: original stmt MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dim[0].stride = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: 	stmt 0 MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: 	stmt 1 MEM[(struct field_type *)&self].halo.dim[0].stride = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note:   based on:     MEM[(struct field_type *)&self].halo.dim[0].lbound = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: misalign = 8 bytes of ref MEM[(struct field_type *)&self].halo.span
gnu_opt_report.txt:field_mod.f90:978:0: note: ==> examining statement: MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: ------>vectorizing SLP node starting from: MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: create vector_type-pointer variable to type: vector(2) integer(kind=8)  vectorizing a pointer ref: MEM[(struct field_type *)&self].halo.span
gnu_opt_report.txt:field_mod.f90:978:0: note: created &MEM[(struct field_type *)&self].halo.span
gnu_opt_report.txt:field_mod.f90:589:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstart = _488;
gnu_opt_report.txt:field_mod.f90:589:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstop = _489;
gnu_opt_report.txt:field_mod.f90:589:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:589:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].internal.xstart = _488;
gnu_opt_report.txt:field_mod.f90:589:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstart = _488;
gnu_opt_report.txt:field_mod.f90:589:0: note:   based on:     MEM[(struct field_type *)&self].internal.xstart = _488;
gnu_opt_report.txt:field_mod.f90:596:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystart = _493;
gnu_opt_report.txt:field_mod.f90:596:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystop = _495;
gnu_opt_report.txt:field_mod.f90:596:0: note: got vectype for stmt: pretmp_1515 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:596:0: note: got vectype for stmt: pretmp_1529 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:596:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:596:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.ystart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:596:0: note: Detected interleaving load of size 2 starting with pretmp_1529 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:596:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].internal.ystart = _493;
gnu_opt_report.txt:field_mod.f90:596:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystart = _493;
gnu_opt_report.txt:field_mod.f90:596:0: note:   based on:     MEM[(struct field_type *)&self].internal.ystart = _493;
gnu_opt_report.txt:field_mod.f90:598:0: note: got vectype for stmt: pretmp_1507 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:598:0: note: got vectype for stmt: pretmp_1521 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:598:0: note: got vectype for stmt: pretmp_1535 = MEM[(struct field_type *)&self].internal.ystop;
gnu_opt_report.txt:field_mod.f90:598:0: note: got vectype for stmt: pretmp_1549 = MEM[(struct field_type *)&self].internal.ystart;
gnu_opt_report.txt:field_mod.f90:598:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:598:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystart
gnu_opt_report.txt:field_mod.f90:598:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:598:0: note: Detected interleaving load of size 4 starting with pretmp_1521 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:488:0: note: got vectype for stmt: pretmp_1514 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:488:0: note: got vectype for stmt: pretmp_1528 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:488:0: note: got vectype for stmt: pretmp_1542 = MEM[(struct field_type *)&self].internal.ystop;
gnu_opt_report.txt:field_mod.f90:488:0: note: got vectype for stmt: pretmp_1556 = MEM[(struct field_type *)&self].internal.ystart;
gnu_opt_report.txt:field_mod.f90:488:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:488:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystart
gnu_opt_report.txt:field_mod.f90:488:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:488:0: note: Detected interleaving load of size 4 starting with pretmp_1528 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:620:0: note: got vectype for stmt: MEM[(struct field_type *)&self].defined_on = 2;
gnu_opt_report.txt:field_mod.f90:620:0: note: not consecutive access MEM[(struct field_type *)&self].defined_on = 2;
gnu_opt_report.txt:field_mod.f90:968:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstart = _501;
gnu_opt_report.txt:field_mod.f90:968:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstop = _502;
gnu_opt_report.txt:field_mod.f90:968:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystart = _503;
gnu_opt_report.txt:field_mod.f90:968:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystop = _504;
gnu_opt_report.txt:field_mod.f90:968:0: note: got vectype for stmt: MEM[(struct field_type *)&self].num_halos = 0;
gnu_opt_report.txt:field_mod.f90:968:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:968:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystart
gnu_opt_report.txt:field_mod.f90:968:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:968:0: note: Detected interleaving store of size 4 starting with MEM[(struct field_type *)&self].internal.xstart = _501;
gnu_opt_report.txt:field_mod.f90:968:0: note: not consecutive access MEM[(struct field_type *)&self].num_halos = 0;
gnu_opt_report.txt:field_mod.f90:968:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstart = _501;
gnu_opt_report.txt:field_mod.f90:968:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstop = _502;
gnu_opt_report.txt:field_mod.f90:968:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystart = _503;
gnu_opt_report.txt:field_mod.f90:968:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystop = _504;
gnu_opt_report.txt:field_mod.f90:968:0: note: 	stmt 0 MEM[(struct field_type *)&self].internal.xstart = _501;
gnu_opt_report.txt:field_mod.f90:968:0: note: 	stmt 1 MEM[(struct field_type *)&self].internal.xstop = _502;
gnu_opt_report.txt:field_mod.f90:968:0: note: 	stmt 2 MEM[(struct field_type *)&self].internal.ystart = _503;
gnu_opt_report.txt:field_mod.f90:968:0: note: 	stmt 3 MEM[(struct field_type *)&self].internal.ystop = _504;
gnu_opt_report.txt:field_mod.f90:968:0: note:   based on:     MEM[(struct field_type *)&self].internal.xstart = _501;
gnu_opt_report.txt:field_mod.f90:968:0: note: misalign = 8 bytes of ref MEM[(struct field_type *)&self].internal.xstart
gnu_opt_report.txt:field_mod.f90:968:0: note: ==> examining statement: MEM[(struct field_type *)&self].internal.xstart = _501;
gnu_opt_report.txt:field_mod.f90:968:0: note: ------>vectorizing SLP node starting from: MEM[(struct field_type *)&self].internal.xstart = _501;
gnu_opt_report.txt:field_mod.f90:968:0: note: create vector_type-pointer variable to type: vector(4) integer(kind=4)  vectorizing a pointer ref: MEM[(struct field_type *)&self].internal.xstart
gnu_opt_report.txt:field_mod.f90:968:0: note: created &MEM[(struct field_type *)&self].internal.xstart
gnu_opt_report.txt:field_mod.f90:969:0: note: got vectype for stmt: MEM[(struct field_type *)&self].num_halos = 2;
gnu_opt_report.txt:field_mod.f90:972:0: note: got vectype for stmt: MEM[(struct field_type *)&self].num_halos = prephitmp_1796;
gnu_opt_report.txt:field_mod.f90:975:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dtype.elem_len = 52;
gnu_opt_report.txt:field_mod.f90:975:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dtype.rank = 1;
gnu_opt_report.txt:field_mod.f90:975:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dtype.type = 5;
gnu_opt_report.txt:field_mod.f90:975:0: note: Detected interleaving store MEM[(struct field_type *)&self].halo.dtype.rank and MEM[(struct field_type *)&self].halo.dtype.type
gnu_opt_report.txt:field_mod.f90:975:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].halo.dtype.rank = 1;
gnu_opt_report.txt:field_mod.f90:975:0: note: not consecutive access MEM[(struct field_type *)&self].halo.dtype.elem_len = 52;
gnu_opt_report.txt:field_mod.f90:975:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dtype.rank = 1;
gnu_opt_report.txt:field_mod.f90:975:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.data = _522;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dim[0].lbound = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dim[0].ubound = _527;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dim[0].stride = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.offset = -1;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving store MEM[(struct field_type *)&self].halo.span and MEM[(struct field_type *)&self].halo.dim[0].stride
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving store MEM[(struct field_type *)&self].halo.span and MEM[(struct field_type *)&self].halo.dim[0].lbound
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving store MEM[(struct field_type *)&self].halo.span and MEM[(struct field_type *)&self].halo.dim[0].ubound
gnu_opt_report.txt:field_mod.f90:978:0: note: not consecutive access MEM[(struct field_type *)&self].halo.offset = -1;
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving store of size 4 starting with MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dim[0].stride = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dim[0].lbound = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dim[0].ubound = _527;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP failed: different operation in stmt MEM[(struct field_type *)&self].halo.dim[0].ubound = _527;
gnu_opt_report.txt:field_mod.f90:978:0: note: original stmt MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dim[0].stride = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: 	stmt 0 MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: 	stmt 1 MEM[(struct field_type *)&self].halo.dim[0].stride = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note:   based on:     MEM[(struct field_type *)&self].halo.dim[0].lbound = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: misalign = 8 bytes of ref MEM[(struct field_type *)&self].halo.span
gnu_opt_report.txt:field_mod.f90:978:0: note: ==> examining statement: MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: ------>vectorizing SLP node starting from: MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: create vector_type-pointer variable to type: vector(2) integer(kind=8)  vectorizing a pointer ref: MEM[(struct field_type *)&self].halo.span
gnu_opt_report.txt:field_mod.f90:978:0: note: created &MEM[(struct field_type *)&self].halo.span
gnu_opt_report.txt:field_mod.f90:692:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstart = _552;
gnu_opt_report.txt:field_mod.f90:692:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstop = _553;
gnu_opt_report.txt:field_mod.f90:692:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:692:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].internal.xstart = _552;
gnu_opt_report.txt:field_mod.f90:692:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstart = _552;
gnu_opt_report.txt:field_mod.f90:692:0: note:   based on:     MEM[(struct field_type *)&self].internal.xstart = _552;
gnu_opt_report.txt:field_mod.f90:701:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystart = _557;
gnu_opt_report.txt:field_mod.f90:701:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystop = _558;
gnu_opt_report.txt:field_mod.f90:701:0: note: got vectype for stmt: pretmp_1512 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:701:0: note: got vectype for stmt: pretmp_1526 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:701:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:701:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.ystart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:701:0: note: Detected interleaving load of size 2 starting with pretmp_1526 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:701:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].internal.ystart = _557;
gnu_opt_report.txt:field_mod.f90:701:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystart = _557;
gnu_opt_report.txt:field_mod.f90:701:0: note:   based on:     MEM[(struct field_type *)&self].internal.ystart = _557;
gnu_opt_report.txt:field_mod.f90:703:0: note: got vectype for stmt: pretmp_1508 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:703:0: note: got vectype for stmt: pretmp_1522 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:703:0: note: got vectype for stmt: pretmp_1536 = MEM[(struct field_type *)&self].internal.ystop;
gnu_opt_report.txt:field_mod.f90:703:0: note: got vectype for stmt: pretmp_1550 = MEM[(struct field_type *)&self].internal.ystart;
gnu_opt_report.txt:field_mod.f90:703:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:703:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystart
gnu_opt_report.txt:field_mod.f90:703:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:703:0: note: Detected interleaving load of size 4 starting with pretmp_1522 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:620:0: note: got vectype for stmt: pretmp_1511 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:620:0: note: got vectype for stmt: pretmp_1525 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:620:0: note: got vectype for stmt: pretmp_1540 = MEM[(struct field_type *)&self].internal.ystop;
gnu_opt_report.txt:field_mod.f90:620:0: note: got vectype for stmt: pretmp_1554 = MEM[(struct field_type *)&self].internal.ystart;
gnu_opt_report.txt:field_mod.f90:620:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:620:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystart
gnu_opt_report.txt:field_mod.f90:620:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:620:0: note: Detected interleaving load of size 4 starting with pretmp_1525 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:725:0: note: got vectype for stmt: MEM[(struct field_type *)&self].defined_on = 3;
gnu_opt_report.txt:field_mod.f90:725:0: note: not consecutive access MEM[(struct field_type *)&self].defined_on = 3;
gnu_opt_report.txt:field_mod.f90:748:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstart = pretmp_1745;
gnu_opt_report.txt:field_mod.f90:748:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstop = _568;
gnu_opt_report.txt:field_mod.f90:748:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:748:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].internal.xstart = pretmp_1745;
gnu_opt_report.txt:field_mod.f90:748:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstart = pretmp_1745;
gnu_opt_report.txt:field_mod.f90:748:0: note:   based on:     MEM[(struct field_type *)&self].internal.xstart = pretmp_1745;
gnu_opt_report.txt:field_mod.f90:754:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstart = _570;
gnu_opt_report.txt:field_mod.f90:754:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstop = _571;
gnu_opt_report.txt:field_mod.f90:754:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:754:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].internal.xstart = _570;
gnu_opt_report.txt:field_mod.f90:754:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstart = _570;
gnu_opt_report.txt:field_mod.f90:754:0: note:   based on:     MEM[(struct field_type *)&self].internal.xstart = _570;
gnu_opt_report.txt:field_mod.f90:759:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystart = pretmp_1759;
gnu_opt_report.txt:field_mod.f90:759:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystop = _578;
gnu_opt_report.txt:field_mod.f90:759:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.ystart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:759:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].internal.ystart = pretmp_1759;
gnu_opt_report.txt:field_mod.f90:759:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystart = pretmp_1759;
gnu_opt_report.txt:field_mod.f90:759:0: note:   based on:     MEM[(struct field_type *)&self].internal.ystart = pretmp_1759;
gnu_opt_report.txt:field_mod.f90:765:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystart = _580;
gnu_opt_report.txt:field_mod.f90:765:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystop = _581;
gnu_opt_report.txt:field_mod.f90:765:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.ystart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:765:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].internal.ystart = _580;
gnu_opt_report.txt:field_mod.f90:765:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystart = _580;
gnu_opt_report.txt:field_mod.f90:765:0: note:   based on:     MEM[(struct field_type *)&self].internal.ystart = _580;
gnu_opt_report.txt:field_mod.f90:968:0: note: got vectype for stmt: MEM[(struct field_type *)&self].num_halos = 0;
gnu_opt_report.txt:field_mod.f90:968:0: note: not consecutive access MEM[(struct field_type *)&self].num_halos = 0;
gnu_opt_report.txt:field_mod.f90:969:0: note: got vectype for stmt: MEM[(struct field_type *)&self].num_halos = 2;
gnu_opt_report.txt:field_mod.f90:972:0: note: got vectype for stmt: MEM[(struct field_type *)&self].num_halos = prephitmp_1767;
gnu_opt_report.txt:field_mod.f90:975:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dtype.elem_len = 52;
gnu_opt_report.txt:field_mod.f90:975:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dtype.rank = 1;
gnu_opt_report.txt:field_mod.f90:975:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dtype.type = 5;
gnu_opt_report.txt:field_mod.f90:975:0: note: Detected interleaving store MEM[(struct field_type *)&self].halo.dtype.rank and MEM[(struct field_type *)&self].halo.dtype.type
gnu_opt_report.txt:field_mod.f90:975:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].halo.dtype.rank = 1;
gnu_opt_report.txt:field_mod.f90:975:0: note: not consecutive access MEM[(struct field_type *)&self].halo.dtype.elem_len = 52;
gnu_opt_report.txt:field_mod.f90:975:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dtype.rank = 1;
gnu_opt_report.txt:field_mod.f90:975:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.data = _599;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dim[0].lbound = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dim[0].ubound = _604;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dim[0].stride = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.offset = -1;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: pretmp_1778 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: pretmp_1780 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving store MEM[(struct field_type *)&self].halo.span and MEM[(struct field_type *)&self].halo.dim[0].stride
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving store MEM[(struct field_type *)&self].halo.span and MEM[(struct field_type *)&self].halo.dim[0].lbound
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving store MEM[(struct field_type *)&self].halo.span and MEM[(struct field_type *)&self].halo.dim[0].ubound
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving load of size 2 starting with pretmp_1780 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:978:0: note: not consecutive access MEM[(struct field_type *)&self].halo.offset = -1;
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving store of size 4 starting with MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dim[0].stride = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dim[0].lbound = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dim[0].ubound = _604;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP failed: different operation in stmt MEM[(struct field_type *)&self].halo.dim[0].ubound = _604;
gnu_opt_report.txt:field_mod.f90:978:0: note: original stmt MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dim[0].stride = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: 	stmt 0 MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: 	stmt 1 MEM[(struct field_type *)&self].halo.dim[0].stride = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note:   based on:     MEM[(struct field_type *)&self].halo.dim[0].lbound = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: misalign = 8 bytes of ref MEM[(struct field_type *)&self].halo.span
gnu_opt_report.txt:field_mod.f90:978:0: note: ==> examining statement: MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: ------>vectorizing SLP node starting from: MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: create vector_type-pointer variable to type: vector(2) integer(kind=8)  vectorizing a pointer ref: MEM[(struct field_type *)&self].halo.span
gnu_opt_report.txt:field_mod.f90:978:0: note: created &MEM[(struct field_type *)&self].halo.span
gnu_opt_report.txt:field_mod.f90:1001:0: note: def_stmt: pretmp_1780 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:1001:0: note: def_stmt: pretmp_1780 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:1001:0: note: def_stmt: pretmp_1778 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:1001:0: note: def_stmt: pretmp_1778 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:1001:0: note: def_stmt: pretmp_1780 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:1001:0: note: def_stmt: pretmp_1780 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:1001:0: note: def_stmt: pretmp_1778 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:1001:0: note: def_stmt: pretmp_1778 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:1001:0: note: def_stmt: pretmp_1780 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:1001:0: note: def_stmt: pretmp_1778 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:1001:0: note: def_stmt: pretmp_1780 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:1001:0: note: def_stmt: pretmp_1780 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:1001:0: note: def_stmt: pretmp_1778 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:1001:0: note: def_stmt: pretmp_1778 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:821:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstart = _629;
gnu_opt_report.txt:field_mod.f90:821:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstop = _631;
gnu_opt_report.txt:field_mod.f90:821:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:821:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].internal.xstart = _629;
gnu_opt_report.txt:field_mod.f90:821:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstart = _629;
gnu_opt_report.txt:field_mod.f90:821:0: note:   based on:     MEM[(struct field_type *)&self].internal.xstart = _629;
gnu_opt_report.txt:field_mod.f90:823:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystart = _633;
gnu_opt_report.txt:field_mod.f90:823:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystop = _635;
gnu_opt_report.txt:field_mod.f90:823:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.ystart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:823:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].internal.ystart = _633;
gnu_opt_report.txt:field_mod.f90:823:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystart = _633;
gnu_opt_report.txt:field_mod.f90:823:0: note:   based on:     MEM[(struct field_type *)&self].internal.ystart = _633;
gnu_opt_report.txt:field_mod.f90:825:0: note: got vectype for stmt: pretmp_1537 = MEM[(struct field_type *)&self].internal.ystop;
gnu_opt_report.txt:field_mod.f90:825:0: note: got vectype for stmt: pretmp_1551 = MEM[(struct field_type *)&self].internal.ystart;
gnu_opt_report.txt:field_mod.f90:825:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.ystart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:825:0: note: Detected interleaving load of size 2 starting with pretmp_1551 = MEM[(struct field_type *)&self].internal.ystart;
gnu_opt_report.txt:field_mod.f90:725:0: note: got vectype for stmt: pretmp_1510 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:725:0: note: got vectype for stmt: pretmp_1524 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:725:0: note: got vectype for stmt: pretmp_1539 = MEM[(struct field_type *)&self].internal.ystop;
gnu_opt_report.txt:field_mod.f90:725:0: note: got vectype for stmt: pretmp_1553 = MEM[(struct field_type *)&self].internal.ystart;
gnu_opt_report.txt:field_mod.f90:725:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:725:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystart
gnu_opt_report.txt:field_mod.f90:725:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:725:0: note: Detected interleaving load of size 4 starting with pretmp_1524 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:296:0: note: got vectype for stmt: MEM[(struct field_type *)&self].defined_on = 4;
gnu_opt_report.txt:field_mod.f90:296:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstart = 1;
gnu_opt_report.txt:field_mod.f90:296:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstop = m_326;
gnu_opt_report.txt:field_mod.f90:296:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystart = 1;
gnu_opt_report.txt:field_mod.f90:296:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystop = n_327;
gnu_opt_report.txt:field_mod.f90:296:0: note: got vectype for stmt: MEM[(struct field_type *)&self].num_halos = 0;
gnu_opt_report.txt:field_mod.f90:296:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:296:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystart
gnu_opt_report.txt:field_mod.f90:296:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:296:0: note: not consecutive access MEM[(struct field_type *)&self].defined_on = 4;
gnu_opt_report.txt:field_mod.f90:296:0: note: Detected interleaving store of size 4 starting with MEM[(struct field_type *)&self].internal.xstart = 1;
gnu_opt_report.txt:field_mod.f90:296:0: note: not consecutive access MEM[(struct field_type *)&self].num_halos = 0;
gnu_opt_report.txt:field_mod.f90:296:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstart = 1;
gnu_opt_report.txt:field_mod.f90:296:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstop = m_326;
gnu_opt_report.txt:field_mod.f90:296:0: note: Build SLP failed: different operation in stmt MEM[(struct field_type *)&self].internal.xstop = m_326;
gnu_opt_report.txt:field_mod.f90:296:0: note: original stmt MEM[(struct field_type *)&self].internal.xstart = 1;
gnu_opt_report.txt:field_mod.f90:296:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystart = 1;
gnu_opt_report.txt:field_mod.f90:296:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystop = n_327;
gnu_opt_report.txt:field_mod.f90:296:0: note: Build SLP failed: different operation in stmt MEM[(struct field_type *)&self].internal.ystop = n_327;
gnu_opt_report.txt:field_mod.f90:296:0: note: original stmt MEM[(struct field_type *)&self].internal.xstart = 1;
gnu_opt_report.txt:field_mod.f90:296:0: note:   based on:     MEM[(struct field_type *)&self].defined_on = 4;
gnu_opt_report.txt:field_mod.f90:243:0: note: got vectype for stmt: pretmp_1509 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:243:0: note: got vectype for stmt: pretmp_1523 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:243:0: note: got vectype for stmt: pretmp_1538 = MEM[(struct field_type *)&self].internal.ystop;
gnu_opt_report.txt:field_mod.f90:243:0: note: got vectype for stmt: pretmp_1552 = MEM[(struct field_type *)&self].internal.ystart;
gnu_opt_report.txt:field_mod.f90:243:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:243:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystart
gnu_opt_report.txt:field_mod.f90:243:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:243:0: note: Detected interleaving load of size 4 starting with pretmp_1523 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:1340:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.nx = _332;
gnu_opt_report.txt:field_mod.f90:1340:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ny = _336;
gnu_opt_report.txt:field_mod.f90:1340:0: note: got vectype for stmt: MEM[(struct field_type *)&self].whole.xstop = prephitmp_1609;
gnu_opt_report.txt:field_mod.f90:1340:0: note: got vectype for stmt: MEM[(struct field_type *)&self].whole.xstart = prephitmp_1593;
gnu_opt_report.txt:field_mod.f90:1340:0: note: got vectype for stmt: MEM[(struct field_type *)&self].whole.ystop = prephitmp_1655;
gnu_opt_report.txt:field_mod.f90:1340:0: note: got vectype for stmt: MEM[(struct field_type *)&self].whole.ystart = prephitmp_1638;
gnu_opt_report.txt:field_mod.f90:1340:0: note: got vectype for stmt: MEM[(struct field_type *)&self].whole.nx = _352;
gnu_opt_report.txt:field_mod.f90:1340:0: note: got vectype for stmt: MEM[(struct field_type *)&self].whole.ny = _356;
gnu_opt_report.txt:field_mod.f90:1340:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.nx and MEM[(struct field_type *)&self].internal.ny
gnu_opt_report.txt:field_mod.f90:1340:0: note: Detected interleaving store MEM[(struct field_type *)&self].whole.nx and MEM[(struct field_type *)&self].whole.ny
gnu_opt_report.txt:field_mod.f90:1340:0: note: Detected interleaving store MEM[(struct field_type *)&self].whole.nx and MEM[(struct field_type *)&self].whole.xstart
gnu_opt_report.txt:field_mod.f90:1340:0: note: Detected interleaving store MEM[(struct field_type *)&self].whole.nx and MEM[(struct field_type *)&self].whole.xstop
gnu_opt_report.txt:field_mod.f90:1340:0: note: Detected interleaving store MEM[(struct field_type *)&self].whole.nx and MEM[(struct field_type *)&self].whole.ystart
gnu_opt_report.txt:field_mod.f90:1340:0: note: Detected interleaving store MEM[(struct field_type *)&self].whole.nx and MEM[(struct field_type *)&self].whole.ystop
gnu_opt_report.txt:field_mod.f90:1340:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].internal.nx = _332;
gnu_opt_report.txt:field_mod.f90:1340:0: note: Detected interleaving store of size 6 starting with MEM[(struct field_type *)&self].whole.nx = _352;
gnu_opt_report.txt:field_mod.f90:1340:0: note: Build SLP for MEM[(struct field_type *)&self].internal.nx = _332;
gnu_opt_report.txt:field_mod.f90:1340:0: note: Build SLP for MEM[(struct field_type *)&self].whole.nx = _352;
gnu_opt_report.txt:field_mod.f90:1340:0: note: Build SLP for MEM[(struct field_type *)&self].whole.ny = _356;
gnu_opt_report.txt:field_mod.f90:1340:0: note: Build SLP for MEM[(struct field_type *)&self].whole.xstart = prephitmp_1593;
gnu_opt_report.txt:field_mod.f90:1340:0: note: Build SLP for MEM[(struct field_type *)&self].whole.xstop = prephitmp_1609;
gnu_opt_report.txt:field_mod.f90:1340:0: note: Build SLP for MEM[(struct field_type *)&self].whole.ystart = prephitmp_1638;
gnu_opt_report.txt:field_mod.f90:1340:0: note: Build SLP for MEM[(struct field_type *)&self].whole.ystop = prephitmp_1655;
gnu_opt_report.txt:field_mod.f90:1340:0: note:   based on:     MEM[(struct field_type *)&self].internal.nx = _332;
gnu_opt_report.txt:field_mod.f90:1202:0: note: got vectype for stmt: pretmp_1728 = self.field_type.grid;
gnu_opt_report.txt:field_mod.f90:1202:0: note: not consecutive access pretmp_1728 = self.field_type.grid;
gnu_opt_report.txt: scalar_type: struct field_type
gnu_opt_report.txt:field_mod.f90:1362:0: note: not vectorized: no vectype for stmt: *dst_11(D).field_type = *src_12(D).field_type;
gnu_opt_report.txt: scalar_type: struct field_type
gnu_opt_report.txt:field_mod.f90:1362:0: note: not vectorized: more than one data ref in stmt: *dst_11(D).field_type = *src_12(D).field_type;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _2 = *src_12(D).field_type.halo.dim[0].ubound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _3 = *src_12(D).field_type.halo.dim[0].lbound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: Detected interleaving load *src_12(D).field_type.halo.dim[0].lbound and *src_12(D).field_type.halo.dim[0].ubound
gnu_opt_report.txt:field_mod.f90:1362:0: note: Detected interleaving load of size 2 starting with _3 = *src_12(D).field_type.halo.dim[0].lbound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: *dst_11(D).field_type.halo.data = _18;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: *dst_11(D).field_type.halo.data = 0B;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _87 = MEM[(struct array15_field_type *)array_39(D)].dim[_84].ubound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _88 = MEM[(struct array15_field_type *)array_39(D)].dim[_84].lbound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: Detected interleaving load MEM[(struct array15_field_type *)array_39(D)].dim[_84].lbound and MEM[(struct array15_field_type *)array_39(D)].dim[_84].ubound
gnu_opt_report.txt:field_mod.f90:1362:0: note: Detected interleaving load of size 3 starting with _88 = MEM[(struct array15_field_type *)array_39(D)].dim[_84].lbound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: init: stmt relevant? _87 = MEM[(struct array15_field_type *)array_39(D)].dim[_84].ubound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: init: stmt relevant? _88 = MEM[(struct array15_field_type *)array_39(D)].dim[_84].lbound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: def_stmt: _87 = MEM[(struct array15_field_type *)array_39(D)].dim[_84].ubound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: mark relevant 5, live 0: _87 = MEM[(struct array15_field_type *)array_39(D)].dim[_84].ubound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: def_stmt: _88 = MEM[(struct array15_field_type *)array_39(D)].dim[_84].lbound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: mark relevant 5, live 0: _88 = MEM[(struct array15_field_type *)array_39(D)].dim[_84].lbound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: worklist: examine stmt: _88 = MEM[(struct array15_field_type *)array_39(D)].dim[_84].lbound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: worklist: examine stmt: _87 = MEM[(struct array15_field_type *)array_39(D)].dim[_84].ubound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _268 = MEM[(struct array15_field_type &)array_39(D)].dim[_269].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: Detected single element interleaving MEM[(struct array15_field_type &)array_39(D)].dim[_269].stride step 24
gnu_opt_report.txt:field_mod.f90:1362:0: note: init: stmt relevant? _268 = MEM[(struct array15_field_type &)array_39(D)].dim[_269].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: def_stmt: _268 = MEM[(struct array15_field_type &)array_39(D)].dim[_269].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: mark relevant 5, live 0: _268 = MEM[(struct array15_field_type &)array_39(D)].dim[_269].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: worklist: examine stmt: _268 = MEM[(struct array15_field_type &)array_39(D)].dim[_269].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: ==> examining statement: _268 = MEM[(struct array15_field_type &)array_39(D)].dim[_269].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note:   based on:     _268 = MEM[(struct array15_field_type &)array_39(D)].dim[_269].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: can't force alignment of ref: MEM[(struct array15_field_type &)array_39(D)].dim[_269].stride
gnu_opt_report.txt:field_mod.f90:1362:0: note: ==> examining statement: _268 = MEM[(struct array15_field_type &)array_39(D)].dim[_269].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: vect_is_simple_use: operand MEM[(struct array15_field_type &)array_39(D)].dim[_269].stride
gnu_opt_report.txt:field_mod.f90:1362:0: note: vect_is_simple_use: operand MEM[(struct array15_field_type &)array_39(D)].dim[_269].stride
gnu_opt_report.txt:field_mod.f90:1362:0: note: def_stmt: _268 = MEM[(struct array15_field_type &)array_39(D)].dim[_269].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: pretmp_256 = MEM[(struct array15_field_type &)array_39(D)].dtype.rank;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access pretmp_256 = MEM[(struct array15_field_type &)array_39(D)].dtype.rank;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _245 = MEM[(struct array15_field_type &)array_39(D)].dim[_207].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _245 = MEM[(struct array15_field_type &)array_39(D)].dim[_207].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _186 = MEM[(struct array15_field_type &)array_39(D)].dim[_187].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _186 = MEM[(struct array15_field_type &)array_39(D)].dim[_187].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _180 = MEM[(struct array15_field_type &)array_39(D)].dim[_181].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _180 = MEM[(struct array15_field_type &)array_39(D)].dim[_181].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _174 = MEM[(struct array15_field_type &)array_39(D)].dim[_175].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _174 = MEM[(struct array15_field_type &)array_39(D)].dim[_175].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _168 = MEM[(struct array15_field_type &)array_39(D)].dim[_169].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _168 = MEM[(struct array15_field_type &)array_39(D)].dim[_169].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _162 = MEM[(struct array15_field_type &)array_39(D)].dim[_163].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _162 = MEM[(struct array15_field_type &)array_39(D)].dim[_163].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _156 = MEM[(struct array15_field_type &)array_39(D)].dim[_157].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _156 = MEM[(struct array15_field_type &)array_39(D)].dim[_157].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _148 = MEM[(struct array15_field_type &)array_39(D)].dim[_149].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _148 = MEM[(struct array15_field_type &)array_39(D)].dim[_149].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _118 = MEM[(struct array15_field_type &)array_39(D)].dim[_136].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _118 = MEM[(struct array15_field_type &)array_39(D)].dim[_136].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _34 = MEM[(struct array15_field_type &)array_39(D)].dim[_83].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _34 = MEM[(struct array15_field_type &)array_39(D)].dim[_83].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _28 = MEM[(struct array15_field_type &)array_39(D)].dim[_29].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _28 = MEM[(struct array15_field_type &)array_39(D)].dim[_29].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _296 = MEM[(struct array15_field_type &)array_39(D)].dim[_297].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _296 = MEM[(struct array15_field_type &)array_39(D)].dim[_297].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _281 = MEM[(struct array15_field_type &)array_39(D)].dim[_283].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _281 = MEM[(struct array15_field_type &)array_39(D)].dim[_283].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _240 = MEM[(struct array15_field_type &)array_39(D)].dim[_246].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _240 = MEM[(struct array15_field_type &)array_39(D)].dim[_246].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _58 = MEM[(struct array15_field_type &)array_39(D)].dim[_15].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _58 = MEM[(struct array15_field_type &)array_39(D)].dim[_15].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _75 = MEM[(struct array15_field_type &)array_39(D)].dim[_74].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _75 = MEM[(struct array15_field_type &)array_39(D)].dim[_74].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _268 = MEM[(struct array15_field_type &)array_39(D)].dim[_269].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _268 = MEM[(struct array15_field_type &)array_39(D)].dim[_269].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _87 = MEM[(struct array15_field_type *)array_39(D)].dim[_84].ubound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _88 = MEM[(struct array15_field_type *)array_39(D)].dim[_84].lbound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: Detected interleaving load MEM[(struct array15_field_type *)array_39(D)].dim[_84].lbound and MEM[(struct array15_field_type *)array_39(D)].dim[_84].ubound
gnu_opt_report.txt:field_mod.f90:1362:0: note: Detected interleaving load of size 2 starting with _88 = MEM[(struct array15_field_type *)array_39(D)].dim[_84].lbound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _111 = MEM[(struct array15_field_type &)array_39(D)].data;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: pretmp_294 = MEM[(struct array15_field_type &)array_39(D)].dtype.rank;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: pretmp_257 = MEM[(struct array15_field_type &)array_39(D)].dtype.rank;
gnu_opt_report.txt:field_mod.f90:243:0: note: got vectype for stmt: self.field_type.halo.data = 0B;
gnu_opt_report.txt:field_mod.f90:243:0: note: got vectype for stmt: self.field_type.grid = grid_58(D);
gnu_opt_report.txt:field_mod.f90:243:0: note: got vectype for stmt: self.field_type.data_on_device = 0;
gnu_opt_report.txt:field_mod.f90:243:0: note: not consecutive access self.field_type.data_on_device = 0;
gnu_opt_report.txt:field_mod.f90:243:0: note: not consecutive access self.field_type.grid = grid_58(D);
gnu_opt_report.txt:field_mod.f90:243:0: note: not consecutive access self.field_type.halo.data = 0B;
gnu_opt_report.txt:field_mod.f90:317:0: note: got vectype for stmt: MEM[(struct field_type *)&self].defined_on = 0;
gnu_opt_report.txt:field_mod.f90:317:0: note: not consecutive access MEM[(struct field_type *)&self].defined_on = 0;
gnu_opt_report.txt:field_mod.f90:969:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstart = pretmp_1875;
gnu_opt_report.txt:field_mod.f90:969:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstop = pretmp_1876;
gnu_opt_report.txt:field_mod.f90:969:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystart = pretmp_1877;
gnu_opt_report.txt:field_mod.f90:969:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystop = pretmp_1878;
gnu_opt_report.txt:field_mod.f90:969:0: note: got vectype for stmt: MEM[(struct field_type *)&self].num_halos = 2;
gnu_opt_report.txt:field_mod.f90:969:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:969:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystart
gnu_opt_report.txt:field_mod.f90:969:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:969:0: note: Detected interleaving store of size 4 starting with MEM[(struct field_type *)&self].internal.xstart = pretmp_1875;
gnu_opt_report.txt:field_mod.f90:969:0: note: not consecutive access MEM[(struct field_type *)&self].num_halos = 2;
gnu_opt_report.txt:field_mod.f90:969:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstart = pretmp_1875;
gnu_opt_report.txt:field_mod.f90:969:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstop = pretmp_1876;
gnu_opt_report.txt:field_mod.f90:969:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystart = pretmp_1877;
gnu_opt_report.txt:field_mod.f90:969:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystop = pretmp_1878;
gnu_opt_report.txt:field_mod.f90:969:0: note: 	stmt 0 MEM[(struct field_type *)&self].internal.xstart = pretmp_1875;
gnu_opt_report.txt:field_mod.f90:969:0: note: 	stmt 1 MEM[(struct field_type *)&self].internal.xstop = pretmp_1876;
gnu_opt_report.txt:field_mod.f90:969:0: note: 	stmt 2 MEM[(struct field_type *)&self].internal.ystart = pretmp_1877;
gnu_opt_report.txt:field_mod.f90:969:0: note: 	stmt 3 MEM[(struct field_type *)&self].internal.ystop = pretmp_1878;
gnu_opt_report.txt:field_mod.f90:969:0: note:   based on:     MEM[(struct field_type *)&self].internal.xstart = pretmp_1875;
gnu_opt_report.txt:field_mod.f90:969:0: note: misalign = 8 bytes of ref MEM[(struct field_type *)&self].internal.xstart
gnu_opt_report.txt:field_mod.f90:969:0: note: ==> examining statement: MEM[(struct field_type *)&self].internal.xstart = pretmp_1875;
gnu_opt_report.txt:field_mod.f90:969:0: note: ------>vectorizing SLP node starting from: MEM[(struct field_type *)&self].internal.xstart = pretmp_1875;
gnu_opt_report.txt:field_mod.f90:969:0: note: create vector_type-pointer variable to type: vector(4) integer(kind=4)  vectorizing a pointer ref: MEM[(struct field_type *)&self].internal.xstart
gnu_opt_report.txt:field_mod.f90:969:0: note: created &MEM[(struct field_type *)&self].internal.xstart
gnu_opt_report.txt:field_mod.f90:967:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstart = _366;
gnu_opt_report.txt:field_mod.f90:967:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstop = pretmp_1876;
gnu_opt_report.txt:field_mod.f90:967:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystart = pretmp_1877;
gnu_opt_report.txt:field_mod.f90:967:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystop = pretmp_1878;
gnu_opt_report.txt:field_mod.f90:967:0: note: got vectype for stmt: MEM[(struct field_type *)&self].num_halos = 0;
gnu_opt_report.txt:field_mod.f90:967:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:967:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystart
gnu_opt_report.txt:field_mod.f90:967:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:967:0: note: Detected interleaving store of size 4 starting with MEM[(struct field_type *)&self].internal.xstart = _366;
gnu_opt_report.txt:field_mod.f90:967:0: note: not consecutive access MEM[(struct field_type *)&self].num_halos = 0;
gnu_opt_report.txt:field_mod.f90:967:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstart = _366;
gnu_opt_report.txt:field_mod.f90:967:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstop = pretmp_1876;
gnu_opt_report.txt:field_mod.f90:967:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystart = pretmp_1877;
gnu_opt_report.txt:field_mod.f90:967:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystop = pretmp_1878;
gnu_opt_report.txt:field_mod.f90:967:0: note:   based on:     MEM[(struct field_type *)&self].internal.xstart = _366;
gnu_opt_report.txt:field_mod.f90:972:0: note: got vectype for stmt: MEM[(struct field_type *)&self].num_halos = prephitmp_1880;
gnu_opt_report.txt:field_mod.f90:975:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dtype.elem_len = 52;
gnu_opt_report.txt:field_mod.f90:975:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dtype.rank = 1;
gnu_opt_report.txt:field_mod.f90:975:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dtype.type = 5;
gnu_opt_report.txt:field_mod.f90:975:0: note: Detected interleaving store MEM[(struct field_type *)&self].halo.dtype.rank and MEM[(struct field_type *)&self].halo.dtype.type
gnu_opt_report.txt:field_mod.f90:975:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].halo.dtype.rank = 1;
gnu_opt_report.txt:field_mod.f90:975:0: note: not consecutive access MEM[(struct field_type *)&self].halo.dtype.elem_len = 52;
gnu_opt_report.txt:field_mod.f90:975:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dtype.rank = 1;
gnu_opt_report.txt:field_mod.f90:975:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.data = _387;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dim[0].lbound = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dim[0].ubound = _392;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dim[0].stride = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.offset = -1;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving store MEM[(struct field_type *)&self].halo.span and MEM[(struct field_type *)&self].halo.dim[0].stride
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving store MEM[(struct field_type *)&self].halo.span and MEM[(struct field_type *)&self].halo.dim[0].lbound
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving store MEM[(struct field_type *)&self].halo.span and MEM[(struct field_type *)&self].halo.dim[0].ubound
gnu_opt_report.txt:field_mod.f90:978:0: note: not consecutive access MEM[(struct field_type *)&self].halo.offset = -1;
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving store of size 4 starting with MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dim[0].stride = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dim[0].lbound = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dim[0].ubound = _392;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP failed: different operation in stmt MEM[(struct field_type *)&self].halo.dim[0].ubound = _392;
gnu_opt_report.txt:field_mod.f90:978:0: note: original stmt MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dim[0].stride = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: 	stmt 0 MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: 	stmt 1 MEM[(struct field_type *)&self].halo.dim[0].stride = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note:   based on:     MEM[(struct field_type *)&self].halo.dim[0].lbound = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: misalign = 8 bytes of ref MEM[(struct field_type *)&self].halo.span
gnu_opt_report.txt:field_mod.f90:978:0: note: ==> examining statement: MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: ------>vectorizing SLP node starting from: MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: create vector_type-pointer variable to type: vector(2) integer(kind=8)  vectorizing a pointer ref: MEM[(struct field_type *)&self].halo.span
gnu_opt_report.txt:field_mod.f90:978:0: note: created &MEM[(struct field_type *)&self].halo.span
gnu_opt_report.txt:field_mod.f90:1004:0: note: got vectype for stmt: pretmp_1543 = MEM[(struct field_type *)&self].internal.ystop;
gnu_opt_report.txt:field_mod.f90:1004:0: note: got vectype for stmt: pretmp_1557 = MEM[(struct field_type *)&self].internal.ystart;
gnu_opt_report.txt:field_mod.f90:1004:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.ystart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:1004:0: note: Detected interleaving load of size 2 starting with pretmp_1557 = MEM[(struct field_type *)&self].internal.ystart;
gnu_opt_report.txt:field_mod.f90:1027:0: note: got vectype for stmt: pretmp_1544 = MEM[(struct field_type *)&self].internal.ystop;
gnu_opt_report.txt:field_mod.f90:1027:0: note: got vectype for stmt: pretmp_1558 = MEM[(struct field_type *)&self].internal.ystart;
gnu_opt_report.txt:field_mod.f90:1027:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.ystart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:1027:0: note: Detected interleaving load of size 2 starting with pretmp_1558 = MEM[(struct field_type *)&self].internal.ystart;
gnu_opt_report.txt:field_mod.f90:1027:0: note:   based on:     pretmp_1544 = MEM[(struct field_type *)&self].internal.ystop;
gnu_opt_report.txt:field_mod.f90:455:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstart = _417;
gnu_opt_report.txt:field_mod.f90:455:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstop = _419;
gnu_opt_report.txt:field_mod.f90:455:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:455:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].internal.xstart = _417;
gnu_opt_report.txt:field_mod.f90:455:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstart = _417;
gnu_opt_report.txt:field_mod.f90:455:0: note:   based on:     MEM[(struct field_type *)&self].internal.xstart = _417;
gnu_opt_report.txt:field_mod.f90:461:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystart = _423;
gnu_opt_report.txt:field_mod.f90:461:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystop = _424;
gnu_opt_report.txt:field_mod.f90:461:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.ystart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:461:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].internal.ystart = _423;
gnu_opt_report.txt:field_mod.f90:461:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystart = _423;
gnu_opt_report.txt:field_mod.f90:461:0: note:   based on:     MEM[(struct field_type *)&self].internal.ystart = _423;
gnu_opt_report.txt:field_mod.f90:463:0: note: got vectype for stmt: pretmp_1868 = MEM[(struct field_type *)&self].internal.ystop;
gnu_opt_report.txt:field_mod.f90:463:0: note: got vectype for stmt: pretmp_1870 = MEM[(struct field_type *)&self].internal.ystart;
gnu_opt_report.txt:field_mod.f90:463:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.ystart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:463:0: note: Detected interleaving load of size 2 starting with pretmp_1870 = MEM[(struct field_type *)&self].internal.ystart;
gnu_opt_report.txt:field_mod.f90:467:0: note: got vectype for stmt: MEM[(struct field_type *)&self].num_halos = 0;
gnu_opt_report.txt:field_mod.f90:467:0: note: got vectype for stmt: pretmp_1506 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:467:0: note: got vectype for stmt: pretmp_1520 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:467:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:467:0: note: Detected interleaving load of size 2 starting with pretmp_1520 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:467:0: note: not consecutive access MEM[(struct field_type *)&self].num_halos = 0;
gnu_opt_report.txt:field_mod.f90:317:0: note: got vectype for stmt: pretmp_1517 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:317:0: note: got vectype for stmt: pretmp_1531 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:317:0: note: got vectype for stmt: pretmp_1545 = MEM[(struct field_type *)&self].internal.ystop;
gnu_opt_report.txt:field_mod.f90:317:0: note: got vectype for stmt: pretmp_1559 = MEM[(struct field_type *)&self].internal.ystart;
gnu_opt_report.txt:field_mod.f90:317:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:317:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystart
gnu_opt_report.txt:field_mod.f90:317:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:317:0: note: Detected interleaving load of size 4 starting with pretmp_1531 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:488:0: note: got vectype for stmt: MEM[(struct field_type *)&self].defined_on = 1;
gnu_opt_report.txt:field_mod.f90:488:0: note: not consecutive access MEM[(struct field_type *)&self].defined_on = 1;
gnu_opt_report.txt:field_mod.f90:509:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstart = pretmp_1826;
gnu_opt_report.txt:field_mod.f90:509:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstop = pretmp_1827;
gnu_opt_report.txt:field_mod.f90:509:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystart = pretmp_1824;
gnu_opt_report.txt:field_mod.f90:509:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystop = pretmp_1825;
gnu_opt_report.txt:field_mod.f90:509:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:509:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystart
gnu_opt_report.txt:field_mod.f90:509:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:509:0: note: Detected interleaving store of size 4 starting with MEM[(struct field_type *)&self].internal.xstart = pretmp_1826;
gnu_opt_report.txt:field_mod.f90:509:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstart = pretmp_1826;
gnu_opt_report.txt:field_mod.f90:509:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstop = pretmp_1827;
gnu_opt_report.txt:field_mod.f90:509:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystart = pretmp_1824;
gnu_opt_report.txt:field_mod.f90:509:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystop = pretmp_1825;
gnu_opt_report.txt:field_mod.f90:509:0: note: 	stmt 0 MEM[(struct field_type *)&self].internal.xstart = pretmp_1826;
gnu_opt_report.txt:field_mod.f90:509:0: note: 	stmt 1 MEM[(struct field_type *)&self].internal.xstop = pretmp_1827;
gnu_opt_report.txt:field_mod.f90:509:0: note: 	stmt 2 MEM[(struct field_type *)&self].internal.ystart = pretmp_1824;
gnu_opt_report.txt:field_mod.f90:509:0: note: 	stmt 3 MEM[(struct field_type *)&self].internal.ystop = pretmp_1825;
gnu_opt_report.txt:field_mod.f90:509:0: note:   based on:     MEM[(struct field_type *)&self].internal.xstart = pretmp_1826;
gnu_opt_report.txt:field_mod.f90:509:0: note: misalign = 8 bytes of ref MEM[(struct field_type *)&self].internal.xstart
gnu_opt_report.txt:field_mod.f90:509:0: note: ==> examining statement: MEM[(struct field_type *)&self].internal.xstart = pretmp_1826;
gnu_opt_report.txt:field_mod.f90:509:0: note: ------>vectorizing SLP node starting from: MEM[(struct field_type *)&self].internal.xstart = pretmp_1826;
gnu_opt_report.txt:field_mod.f90:509:0: note: create vector_type-pointer variable to type: vector(4) integer(kind=4)  vectorizing a pointer ref: MEM[(struct field_type *)&self].internal.xstart
gnu_opt_report.txt:field_mod.f90:509:0: note: created &MEM[(struct field_type *)&self].internal.xstart
gnu_opt_report.txt:field_mod.f90:527:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstart = pretmp_1826;
gnu_opt_report.txt:field_mod.f90:527:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstop = pretmp_1827;
gnu_opt_report.txt:field_mod.f90:527:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystart = _439;
gnu_opt_report.txt:field_mod.f90:527:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystop = pretmp_1825;
gnu_opt_report.txt:field_mod.f90:527:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:527:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystart
gnu_opt_report.txt:field_mod.f90:527:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:527:0: note: Detected interleaving store of size 4 starting with MEM[(struct field_type *)&self].internal.xstart = pretmp_1826;
gnu_opt_report.txt:field_mod.f90:527:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstart = pretmp_1826;
gnu_opt_report.txt:field_mod.f90:527:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstop = pretmp_1827;
gnu_opt_report.txt:field_mod.f90:527:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystart = _439;
gnu_opt_report.txt:field_mod.f90:527:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystop = pretmp_1825;
gnu_opt_report.txt:field_mod.f90:527:0: note:   based on:     MEM[(struct field_type *)&self].internal.xstart = pretmp_1826;
gnu_opt_report.txt:field_mod.f90:968:0: note: got vectype for stmt: MEM[(struct field_type *)&self].num_halos = 0;
gnu_opt_report.txt:field_mod.f90:968:0: note: not consecutive access MEM[(struct field_type *)&self].num_halos = 0;
gnu_opt_report.txt:field_mod.f90:969:0: note: got vectype for stmt: MEM[(struct field_type *)&self].num_halos = 2;
gnu_opt_report.txt:field_mod.f90:972:0: note: got vectype for stmt: MEM[(struct field_type *)&self].num_halos = prephitmp_1835;
gnu_opt_report.txt:field_mod.f90:975:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dtype.elem_len = 52;
gnu_opt_report.txt:field_mod.f90:975:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dtype.rank = 1;
gnu_opt_report.txt:field_mod.f90:975:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dtype.type = 5;
gnu_opt_report.txt:field_mod.f90:975:0: note: Detected interleaving store MEM[(struct field_type *)&self].halo.dtype.rank and MEM[(struct field_type *)&self].halo.dtype.type
gnu_opt_report.txt:field_mod.f90:975:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].halo.dtype.rank = 1;
gnu_opt_report.txt:field_mod.f90:975:0: note: not consecutive access MEM[(struct field_type *)&self].halo.dtype.elem_len = 52;
gnu_opt_report.txt:field_mod.f90:975:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dtype.rank = 1;
gnu_opt_report.txt:field_mod.f90:975:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.data = _458;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dim[0].lbound = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dim[0].ubound = _463;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dim[0].stride = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.offset = -1;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving store MEM[(struct field_type *)&self].halo.span and MEM[(struct field_type *)&self].halo.dim[0].stride
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving store MEM[(struct field_type *)&self].halo.span and MEM[(struct field_type *)&self].halo.dim[0].lbound
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving store MEM[(struct field_type *)&self].halo.span and MEM[(struct field_type *)&self].halo.dim[0].ubound
gnu_opt_report.txt:field_mod.f90:978:0: note: not consecutive access MEM[(struct field_type *)&self].halo.offset = -1;
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving store of size 4 starting with MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dim[0].stride = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dim[0].lbound = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dim[0].ubound = _463;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP failed: different operation in stmt MEM[(struct field_type *)&self].halo.dim[0].ubound = _463;
gnu_opt_report.txt:field_mod.f90:978:0: note: original stmt MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dim[0].stride = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: 	stmt 0 MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: 	stmt 1 MEM[(struct field_type *)&self].halo.dim[0].stride = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note:   based on:     MEM[(struct field_type *)&self].halo.dim[0].lbound = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: misalign = 8 bytes of ref MEM[(struct field_type *)&self].halo.span
gnu_opt_report.txt:field_mod.f90:978:0: note: ==> examining statement: MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: ------>vectorizing SLP node starting from: MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: create vector_type-pointer variable to type: vector(2) integer(kind=8)  vectorizing a pointer ref: MEM[(struct field_type *)&self].halo.span
gnu_opt_report.txt:field_mod.f90:978:0: note: created &MEM[(struct field_type *)&self].halo.span
gnu_opt_report.txt:field_mod.f90:589:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstart = _488;
gnu_opt_report.txt:field_mod.f90:589:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstop = _489;
gnu_opt_report.txt:field_mod.f90:589:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:589:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].internal.xstart = _488;
gnu_opt_report.txt:field_mod.f90:589:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstart = _488;
gnu_opt_report.txt:field_mod.f90:589:0: note:   based on:     MEM[(struct field_type *)&self].internal.xstart = _488;
gnu_opt_report.txt:field_mod.f90:596:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystart = _493;
gnu_opt_report.txt:field_mod.f90:596:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystop = _495;
gnu_opt_report.txt:field_mod.f90:596:0: note: got vectype for stmt: pretmp_1515 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:596:0: note: got vectype for stmt: pretmp_1529 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:596:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:596:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.ystart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:596:0: note: Detected interleaving load of size 2 starting with pretmp_1529 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:596:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].internal.ystart = _493;
gnu_opt_report.txt:field_mod.f90:596:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystart = _493;
gnu_opt_report.txt:field_mod.f90:596:0: note:   based on:     MEM[(struct field_type *)&self].internal.ystart = _493;
gnu_opt_report.txt:field_mod.f90:598:0: note: got vectype for stmt: pretmp_1507 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:598:0: note: got vectype for stmt: pretmp_1521 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:598:0: note: got vectype for stmt: pretmp_1535 = MEM[(struct field_type *)&self].internal.ystop;
gnu_opt_report.txt:field_mod.f90:598:0: note: got vectype for stmt: pretmp_1549 = MEM[(struct field_type *)&self].internal.ystart;
gnu_opt_report.txt:field_mod.f90:598:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:598:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystart
gnu_opt_report.txt:field_mod.f90:598:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:598:0: note: Detected interleaving load of size 4 starting with pretmp_1521 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:488:0: note: got vectype for stmt: pretmp_1514 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:488:0: note: got vectype for stmt: pretmp_1528 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:488:0: note: got vectype for stmt: pretmp_1542 = MEM[(struct field_type *)&self].internal.ystop;
gnu_opt_report.txt:field_mod.f90:488:0: note: got vectype for stmt: pretmp_1556 = MEM[(struct field_type *)&self].internal.ystart;
gnu_opt_report.txt:field_mod.f90:488:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:488:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystart
gnu_opt_report.txt:field_mod.f90:488:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:488:0: note: Detected interleaving load of size 4 starting with pretmp_1528 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:620:0: note: got vectype for stmt: MEM[(struct field_type *)&self].defined_on = 2;
gnu_opt_report.txt:field_mod.f90:620:0: note: not consecutive access MEM[(struct field_type *)&self].defined_on = 2;
gnu_opt_report.txt:field_mod.f90:968:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstart = _501;
gnu_opt_report.txt:field_mod.f90:968:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstop = _502;
gnu_opt_report.txt:field_mod.f90:968:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystart = _503;
gnu_opt_report.txt:field_mod.f90:968:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystop = _504;
gnu_opt_report.txt:field_mod.f90:968:0: note: got vectype for stmt: MEM[(struct field_type *)&self].num_halos = 0;
gnu_opt_report.txt:field_mod.f90:968:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:968:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystart
gnu_opt_report.txt:field_mod.f90:968:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:968:0: note: Detected interleaving store of size 4 starting with MEM[(struct field_type *)&self].internal.xstart = _501;
gnu_opt_report.txt:field_mod.f90:968:0: note: not consecutive access MEM[(struct field_type *)&self].num_halos = 0;
gnu_opt_report.txt:field_mod.f90:968:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstart = _501;
gnu_opt_report.txt:field_mod.f90:968:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstop = _502;
gnu_opt_report.txt:field_mod.f90:968:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystart = _503;
gnu_opt_report.txt:field_mod.f90:968:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystop = _504;
gnu_opt_report.txt:field_mod.f90:968:0: note: 	stmt 0 MEM[(struct field_type *)&self].internal.xstart = _501;
gnu_opt_report.txt:field_mod.f90:968:0: note: 	stmt 1 MEM[(struct field_type *)&self].internal.xstop = _502;
gnu_opt_report.txt:field_mod.f90:968:0: note: 	stmt 2 MEM[(struct field_type *)&self].internal.ystart = _503;
gnu_opt_report.txt:field_mod.f90:968:0: note: 	stmt 3 MEM[(struct field_type *)&self].internal.ystop = _504;
gnu_opt_report.txt:field_mod.f90:968:0: note:   based on:     MEM[(struct field_type *)&self].internal.xstart = _501;
gnu_opt_report.txt:field_mod.f90:968:0: note: misalign = 8 bytes of ref MEM[(struct field_type *)&self].internal.xstart
gnu_opt_report.txt:field_mod.f90:968:0: note: ==> examining statement: MEM[(struct field_type *)&self].internal.xstart = _501;
gnu_opt_report.txt:field_mod.f90:968:0: note: ------>vectorizing SLP node starting from: MEM[(struct field_type *)&self].internal.xstart = _501;
gnu_opt_report.txt:field_mod.f90:968:0: note: create vector_type-pointer variable to type: vector(4) integer(kind=4)  vectorizing a pointer ref: MEM[(struct field_type *)&self].internal.xstart
gnu_opt_report.txt:field_mod.f90:968:0: note: created &MEM[(struct field_type *)&self].internal.xstart
gnu_opt_report.txt:field_mod.f90:969:0: note: got vectype for stmt: MEM[(struct field_type *)&self].num_halos = 2;
gnu_opt_report.txt:field_mod.f90:972:0: note: got vectype for stmt: MEM[(struct field_type *)&self].num_halos = prephitmp_1796;
gnu_opt_report.txt:field_mod.f90:975:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dtype.elem_len = 52;
gnu_opt_report.txt:field_mod.f90:975:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dtype.rank = 1;
gnu_opt_report.txt:field_mod.f90:975:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dtype.type = 5;
gnu_opt_report.txt:field_mod.f90:975:0: note: Detected interleaving store MEM[(struct field_type *)&self].halo.dtype.rank and MEM[(struct field_type *)&self].halo.dtype.type
gnu_opt_report.txt:field_mod.f90:975:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].halo.dtype.rank = 1;
gnu_opt_report.txt:field_mod.f90:975:0: note: not consecutive access MEM[(struct field_type *)&self].halo.dtype.elem_len = 52;
gnu_opt_report.txt:field_mod.f90:975:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dtype.rank = 1;
gnu_opt_report.txt:field_mod.f90:975:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.data = _522;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dim[0].lbound = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dim[0].ubound = _527;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dim[0].stride = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.offset = -1;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving store MEM[(struct field_type *)&self].halo.span and MEM[(struct field_type *)&self].halo.dim[0].stride
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving store MEM[(struct field_type *)&self].halo.span and MEM[(struct field_type *)&self].halo.dim[0].lbound
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving store MEM[(struct field_type *)&self].halo.span and MEM[(struct field_type *)&self].halo.dim[0].ubound
gnu_opt_report.txt:field_mod.f90:978:0: note: not consecutive access MEM[(struct field_type *)&self].halo.offset = -1;
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving store of size 4 starting with MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dim[0].stride = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dim[0].lbound = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dim[0].ubound = _527;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP failed: different operation in stmt MEM[(struct field_type *)&self].halo.dim[0].ubound = _527;
gnu_opt_report.txt:field_mod.f90:978:0: note: original stmt MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dim[0].stride = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: 	stmt 0 MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: 	stmt 1 MEM[(struct field_type *)&self].halo.dim[0].stride = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note:   based on:     MEM[(struct field_type *)&self].halo.dim[0].lbound = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: misalign = 8 bytes of ref MEM[(struct field_type *)&self].halo.span
gnu_opt_report.txt:field_mod.f90:978:0: note: ==> examining statement: MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: ------>vectorizing SLP node starting from: MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: create vector_type-pointer variable to type: vector(2) integer(kind=8)  vectorizing a pointer ref: MEM[(struct field_type *)&self].halo.span
gnu_opt_report.txt:field_mod.f90:978:0: note: created &MEM[(struct field_type *)&self].halo.span
gnu_opt_report.txt:field_mod.f90:692:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstart = _552;
gnu_opt_report.txt:field_mod.f90:692:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstop = _553;
gnu_opt_report.txt:field_mod.f90:692:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:692:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].internal.xstart = _552;
gnu_opt_report.txt:field_mod.f90:692:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstart = _552;
gnu_opt_report.txt:field_mod.f90:692:0: note:   based on:     MEM[(struct field_type *)&self].internal.xstart = _552;
gnu_opt_report.txt:field_mod.f90:701:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystart = _557;
gnu_opt_report.txt:field_mod.f90:701:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystop = _558;
gnu_opt_report.txt:field_mod.f90:701:0: note: got vectype for stmt: pretmp_1512 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:701:0: note: got vectype for stmt: pretmp_1526 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:701:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:701:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.ystart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:701:0: note: Detected interleaving load of size 2 starting with pretmp_1526 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:701:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].internal.ystart = _557;
gnu_opt_report.txt:field_mod.f90:701:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystart = _557;
gnu_opt_report.txt:field_mod.f90:701:0: note:   based on:     MEM[(struct field_type *)&self].internal.ystart = _557;
gnu_opt_report.txt:field_mod.f90:703:0: note: got vectype for stmt: pretmp_1508 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:703:0: note: got vectype for stmt: pretmp_1522 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:703:0: note: got vectype for stmt: pretmp_1536 = MEM[(struct field_type *)&self].internal.ystop;
gnu_opt_report.txt:field_mod.f90:703:0: note: got vectype for stmt: pretmp_1550 = MEM[(struct field_type *)&self].internal.ystart;
gnu_opt_report.txt:field_mod.f90:703:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:703:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystart
gnu_opt_report.txt:field_mod.f90:703:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:703:0: note: Detected interleaving load of size 4 starting with pretmp_1522 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:620:0: note: got vectype for stmt: pretmp_1511 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:620:0: note: got vectype for stmt: pretmp_1525 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:620:0: note: got vectype for stmt: pretmp_1540 = MEM[(struct field_type *)&self].internal.ystop;
gnu_opt_report.txt:field_mod.f90:620:0: note: got vectype for stmt: pretmp_1554 = MEM[(struct field_type *)&self].internal.ystart;
gnu_opt_report.txt:field_mod.f90:620:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:620:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystart
gnu_opt_report.txt:field_mod.f90:620:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:620:0: note: Detected interleaving load of size 4 starting with pretmp_1525 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:725:0: note: got vectype for stmt: MEM[(struct field_type *)&self].defined_on = 3;
gnu_opt_report.txt:field_mod.f90:725:0: note: not consecutive access MEM[(struct field_type *)&self].defined_on = 3;
gnu_opt_report.txt:field_mod.f90:748:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstart = pretmp_1745;
gnu_opt_report.txt:field_mod.f90:748:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstop = _568;
gnu_opt_report.txt:field_mod.f90:748:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:748:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].internal.xstart = pretmp_1745;
gnu_opt_report.txt:field_mod.f90:748:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstart = pretmp_1745;
gnu_opt_report.txt:field_mod.f90:748:0: note:   based on:     MEM[(struct field_type *)&self].internal.xstart = pretmp_1745;
gnu_opt_report.txt:field_mod.f90:754:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstart = _570;
gnu_opt_report.txt:field_mod.f90:754:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstop = _571;
gnu_opt_report.txt:field_mod.f90:754:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:754:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].internal.xstart = _570;
gnu_opt_report.txt:field_mod.f90:754:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstart = _570;
gnu_opt_report.txt:field_mod.f90:754:0: note:   based on:     MEM[(struct field_type *)&self].internal.xstart = _570;
gnu_opt_report.txt:field_mod.f90:759:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystart = pretmp_1759;
gnu_opt_report.txt:field_mod.f90:759:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystop = _578;
gnu_opt_report.txt:field_mod.f90:759:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.ystart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:759:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].internal.ystart = pretmp_1759;
gnu_opt_report.txt:field_mod.f90:759:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystart = pretmp_1759;
gnu_opt_report.txt:field_mod.f90:759:0: note:   based on:     MEM[(struct field_type *)&self].internal.ystart = pretmp_1759;
gnu_opt_report.txt:field_mod.f90:765:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystart = _580;
gnu_opt_report.txt:field_mod.f90:765:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystop = _581;
gnu_opt_report.txt:field_mod.f90:765:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.ystart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:765:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].internal.ystart = _580;
gnu_opt_report.txt:field_mod.f90:765:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystart = _580;
gnu_opt_report.txt:field_mod.f90:765:0: note:   based on:     MEM[(struct field_type *)&self].internal.ystart = _580;
gnu_opt_report.txt:field_mod.f90:968:0: note: got vectype for stmt: MEM[(struct field_type *)&self].num_halos = 0;
gnu_opt_report.txt:field_mod.f90:968:0: note: not consecutive access MEM[(struct field_type *)&self].num_halos = 0;
gnu_opt_report.txt:field_mod.f90:969:0: note: got vectype for stmt: MEM[(struct field_type *)&self].num_halos = 2;
gnu_opt_report.txt:field_mod.f90:972:0: note: got vectype for stmt: MEM[(struct field_type *)&self].num_halos = prephitmp_1767;
gnu_opt_report.txt:field_mod.f90:975:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dtype.elem_len = 52;
gnu_opt_report.txt:field_mod.f90:975:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dtype.rank = 1;
gnu_opt_report.txt:field_mod.f90:975:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dtype.type = 5;
gnu_opt_report.txt:field_mod.f90:975:0: note: Detected interleaving store MEM[(struct field_type *)&self].halo.dtype.rank and MEM[(struct field_type *)&self].halo.dtype.type
gnu_opt_report.txt:field_mod.f90:975:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].halo.dtype.rank = 1;
gnu_opt_report.txt:field_mod.f90:975:0: note: not consecutive access MEM[(struct field_type *)&self].halo.dtype.elem_len = 52;
gnu_opt_report.txt:field_mod.f90:975:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dtype.rank = 1;
gnu_opt_report.txt:field_mod.f90:975:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.data = _599;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dim[0].lbound = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dim[0].ubound = _604;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dim[0].stride = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.offset = -1;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: pretmp_1778 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: pretmp_1780 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving store MEM[(struct field_type *)&self].halo.span and MEM[(struct field_type *)&self].halo.dim[0].stride
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving store MEM[(struct field_type *)&self].halo.span and MEM[(struct field_type *)&self].halo.dim[0].lbound
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving store MEM[(struct field_type *)&self].halo.span and MEM[(struct field_type *)&self].halo.dim[0].ubound
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving load of size 2 starting with pretmp_1780 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:978:0: note: not consecutive access MEM[(struct field_type *)&self].halo.offset = -1;
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving store of size 4 starting with MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dim[0].stride = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dim[0].lbound = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dim[0].ubound = _604;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP failed: different operation in stmt MEM[(struct field_type *)&self].halo.dim[0].ubound = _604;
gnu_opt_report.txt:field_mod.f90:978:0: note: original stmt MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dim[0].stride = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: 	stmt 0 MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: 	stmt 1 MEM[(struct field_type *)&self].halo.dim[0].stride = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note:   based on:     MEM[(struct field_type *)&self].halo.dim[0].lbound = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: misalign = 8 bytes of ref MEM[(struct field_type *)&self].halo.span
gnu_opt_report.txt:field_mod.f90:978:0: note: ==> examining statement: MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: ------>vectorizing SLP node starting from: MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: create vector_type-pointer variable to type: vector(2) integer(kind=8)  vectorizing a pointer ref: MEM[(struct field_type *)&self].halo.span
gnu_opt_report.txt:field_mod.f90:978:0: note: created &MEM[(struct field_type *)&self].halo.span
gnu_opt_report.txt:field_mod.f90:1001:0: note: def_stmt: pretmp_1780 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:1001:0: note: def_stmt: pretmp_1780 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:1001:0: note: def_stmt: pretmp_1778 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:1001:0: note: def_stmt: pretmp_1778 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:1001:0: note: def_stmt: pretmp_1780 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:1001:0: note: def_stmt: pretmp_1780 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:1001:0: note: def_stmt: pretmp_1778 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:1001:0: note: def_stmt: pretmp_1778 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:1001:0: note: def_stmt: pretmp_1780 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:1001:0: note: def_stmt: pretmp_1778 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:1001:0: note: def_stmt: pretmp_1780 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:1001:0: note: def_stmt: pretmp_1780 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:1001:0: note: def_stmt: pretmp_1778 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:1001:0: note: def_stmt: pretmp_1778 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:821:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstart = _629;
gnu_opt_report.txt:field_mod.f90:821:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstop = _631;
gnu_opt_report.txt:field_mod.f90:821:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:821:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].internal.xstart = _629;
gnu_opt_report.txt:field_mod.f90:821:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstart = _629;
gnu_opt_report.txt:field_mod.f90:821:0: note:   based on:     MEM[(struct field_type *)&self].internal.xstart = _629;
gnu_opt_report.txt:field_mod.f90:823:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystart = _633;
gnu_opt_report.txt:field_mod.f90:823:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystop = _635;
gnu_opt_report.txt:field_mod.f90:823:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.ystart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:823:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].internal.ystart = _633;
gnu_opt_report.txt:field_mod.f90:823:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystart = _633;
gnu_opt_report.txt:field_mod.f90:823:0: note:   based on:     MEM[(struct field_type *)&self].internal.ystart = _633;
gnu_opt_report.txt:field_mod.f90:825:0: note: got vectype for stmt: pretmp_1537 = MEM[(struct field_type *)&self].internal.ystop;
gnu_opt_report.txt:field_mod.f90:825:0: note: got vectype for stmt: pretmp_1551 = MEM[(struct field_type *)&self].internal.ystart;
gnu_opt_report.txt:field_mod.f90:825:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.ystart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:825:0: note: Detected interleaving load of size 2 starting with pretmp_1551 = MEM[(struct field_type *)&self].internal.ystart;
gnu_opt_report.txt:field_mod.f90:725:0: note: got vectype for stmt: pretmp_1510 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:725:0: note: got vectype for stmt: pretmp_1524 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:725:0: note: got vectype for stmt: pretmp_1539 = MEM[(struct field_type *)&self].internal.ystop;
gnu_opt_report.txt:field_mod.f90:725:0: note: got vectype for stmt: pretmp_1553 = MEM[(struct field_type *)&self].internal.ystart;
gnu_opt_report.txt:field_mod.f90:725:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:725:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystart
gnu_opt_report.txt:field_mod.f90:725:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:725:0: note: Detected interleaving load of size 4 starting with pretmp_1524 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:296:0: note: got vectype for stmt: MEM[(struct field_type *)&self].defined_on = 4;
gnu_opt_report.txt:field_mod.f90:296:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstart = 1;
gnu_opt_report.txt:field_mod.f90:296:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstop = m_326;
gnu_opt_report.txt:field_mod.f90:296:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystart = 1;
gnu_opt_report.txt:field_mod.f90:296:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystop = n_327;
gnu_opt_report.txt:field_mod.f90:296:0: note: got vectype for stmt: MEM[(struct field_type *)&self].num_halos = 0;
gnu_opt_report.txt:field_mod.f90:296:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:296:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystart
gnu_opt_report.txt:field_mod.f90:296:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:296:0: note: not consecutive access MEM[(struct field_type *)&self].defined_on = 4;
gnu_opt_report.txt:field_mod.f90:296:0: note: Detected interleaving store of size 4 starting with MEM[(struct field_type *)&self].internal.xstart = 1;
gnu_opt_report.txt:field_mod.f90:296:0: note: not consecutive access MEM[(struct field_type *)&self].num_halos = 0;
gnu_opt_report.txt:field_mod.f90:296:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstart = 1;
gnu_opt_report.txt:field_mod.f90:296:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstop = m_326;
gnu_opt_report.txt:field_mod.f90:296:0: note: Build SLP failed: different operation in stmt MEM[(struct field_type *)&self].internal.xstop = m_326;
gnu_opt_report.txt:field_mod.f90:296:0: note: original stmt MEM[(struct field_type *)&self].internal.xstart = 1;
gnu_opt_report.txt:field_mod.f90:296:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystart = 1;
gnu_opt_report.txt:field_mod.f90:296:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystop = n_327;
gnu_opt_report.txt:field_mod.f90:296:0: note: Build SLP failed: different operation in stmt MEM[(struct field_type *)&self].internal.ystop = n_327;
gnu_opt_report.txt:field_mod.f90:296:0: note: original stmt MEM[(struct field_type *)&self].internal.xstart = 1;
gnu_opt_report.txt:field_mod.f90:296:0: note:   based on:     MEM[(struct field_type *)&self].defined_on = 4;
gnu_opt_report.txt:field_mod.f90:243:0: note: got vectype for stmt: pretmp_1509 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:243:0: note: got vectype for stmt: pretmp_1523 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:243:0: note: got vectype for stmt: pretmp_1538 = MEM[(struct field_type *)&self].internal.ystop;
gnu_opt_report.txt:field_mod.f90:243:0: note: got vectype for stmt: pretmp_1552 = MEM[(struct field_type *)&self].internal.ystart;
gnu_opt_report.txt:field_mod.f90:243:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:243:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystart
gnu_opt_report.txt:field_mod.f90:243:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:243:0: note: Detected interleaving load of size 4 starting with pretmp_1523 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:1340:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.nx = _332;
gnu_opt_report.txt:field_mod.f90:1340:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ny = _336;
gnu_opt_report.txt:field_mod.f90:1340:0: note: got vectype for stmt: MEM[(struct field_type *)&self].whole.xstop = prephitmp_1609;
gnu_opt_report.txt:field_mod.f90:1340:0: note: got vectype for stmt: MEM[(struct field_type *)&self].whole.xstart = prephitmp_1593;
gnu_opt_report.txt:field_mod.f90:1340:0: note: got vectype for stmt: MEM[(struct field_type *)&self].whole.ystop = prephitmp_1655;
gnu_opt_report.txt:field_mod.f90:1340:0: note: got vectype for stmt: MEM[(struct field_type *)&self].whole.ystart = prephitmp_1638;
gnu_opt_report.txt:field_mod.f90:1340:0: note: got vectype for stmt: MEM[(struct field_type *)&self].whole.nx = _352;
gnu_opt_report.txt:field_mod.f90:1340:0: note: got vectype for stmt: MEM[(struct field_type *)&self].whole.ny = _356;
gnu_opt_report.txt:field_mod.f90:1340:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.nx and MEM[(struct field_type *)&self].internal.ny
gnu_opt_report.txt:field_mod.f90:1340:0: note: Detected interleaving store MEM[(struct field_type *)&self].whole.nx and MEM[(struct field_type *)&self].whole.ny
gnu_opt_report.txt:field_mod.f90:1340:0: note: Detected interleaving store MEM[(struct field_type *)&self].whole.nx and MEM[(struct field_type *)&self].whole.xstart
gnu_opt_report.txt:field_mod.f90:1340:0: note: Detected interleaving store MEM[(struct field_type *)&self].whole.nx and MEM[(struct field_type *)&self].whole.xstop
gnu_opt_report.txt:field_mod.f90:1340:0: note: Detected interleaving store MEM[(struct field_type *)&self].whole.nx and MEM[(struct field_type *)&self].whole.ystart
gnu_opt_report.txt:field_mod.f90:1340:0: note: Detected interleaving store MEM[(struct field_type *)&self].whole.nx and MEM[(struct field_type *)&self].whole.ystop
gnu_opt_report.txt:field_mod.f90:1340:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].internal.nx = _332;
gnu_opt_report.txt:field_mod.f90:1340:0: note: Detected interleaving store of size 6 starting with MEM[(struct field_type *)&self].whole.nx = _352;
gnu_opt_report.txt:field_mod.f90:1340:0: note: Build SLP for MEM[(struct field_type *)&self].internal.nx = _332;
gnu_opt_report.txt:field_mod.f90:1340:0: note: Build SLP for MEM[(struct field_type *)&self].whole.nx = _352;
gnu_opt_report.txt:field_mod.f90:1340:0: note: Build SLP for MEM[(struct field_type *)&self].whole.ny = _356;
gnu_opt_report.txt:field_mod.f90:1340:0: note: Build SLP for MEM[(struct field_type *)&self].whole.xstart = prephitmp_1593;
gnu_opt_report.txt:field_mod.f90:1340:0: note: Build SLP for MEM[(struct field_type *)&self].whole.xstop = prephitmp_1609;
gnu_opt_report.txt:field_mod.f90:1340:0: note: Build SLP for MEM[(struct field_type *)&self].whole.ystart = prephitmp_1638;
gnu_opt_report.txt:field_mod.f90:1340:0: note: Build SLP for MEM[(struct field_type *)&self].whole.ystop = prephitmp_1655;
gnu_opt_report.txt:field_mod.f90:1340:0: note:   based on:     MEM[(struct field_type *)&self].internal.nx = _332;
gnu_opt_report.txt:field_mod.f90:1202:0: note: got vectype for stmt: pretmp_1728 = self.field_type.grid;
gnu_opt_report.txt:field_mod.f90:1202:0: note: not consecutive access pretmp_1728 = self.field_type.grid;
gnu_opt_report.txt: scalar_type: struct field_type
gnu_opt_report.txt:field_mod.f90:1362:0: note: not vectorized: no vectype for stmt: *dst_11(D).field_type = *src_12(D).field_type;
gnu_opt_report.txt: scalar_type: struct field_type
gnu_opt_report.txt:field_mod.f90:1362:0: note: not vectorized: more than one data ref in stmt: *dst_11(D).field_type = *src_12(D).field_type;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _2 = *src_12(D).field_type.halo.dim[0].ubound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _3 = *src_12(D).field_type.halo.dim[0].lbound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: Detected interleaving load *src_12(D).field_type.halo.dim[0].lbound and *src_12(D).field_type.halo.dim[0].ubound
gnu_opt_report.txt:field_mod.f90:1362:0: note: Detected interleaving load of size 2 starting with _3 = *src_12(D).field_type.halo.dim[0].lbound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: *dst_11(D).field_type.halo.data = _18;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: *dst_11(D).field_type.halo.data = 0B;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _87 = MEM[(struct array15_field_type *)array_39(D)].dim[_84].ubound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _88 = MEM[(struct array15_field_type *)array_39(D)].dim[_84].lbound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: Detected interleaving load MEM[(struct array15_field_type *)array_39(D)].dim[_84].lbound and MEM[(struct array15_field_type *)array_39(D)].dim[_84].ubound
gnu_opt_report.txt:field_mod.f90:1362:0: note: Detected interleaving load of size 3 starting with _88 = MEM[(struct array15_field_type *)array_39(D)].dim[_84].lbound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: init: stmt relevant? _87 = MEM[(struct array15_field_type *)array_39(D)].dim[_84].ubound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: init: stmt relevant? _88 = MEM[(struct array15_field_type *)array_39(D)].dim[_84].lbound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: def_stmt: _87 = MEM[(struct array15_field_type *)array_39(D)].dim[_84].ubound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: mark relevant 5, live 0: _87 = MEM[(struct array15_field_type *)array_39(D)].dim[_84].ubound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: def_stmt: _88 = MEM[(struct array15_field_type *)array_39(D)].dim[_84].lbound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: mark relevant 5, live 0: _88 = MEM[(struct array15_field_type *)array_39(D)].dim[_84].lbound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: worklist: examine stmt: _88 = MEM[(struct array15_field_type *)array_39(D)].dim[_84].lbound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: worklist: examine stmt: _87 = MEM[(struct array15_field_type *)array_39(D)].dim[_84].ubound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _268 = MEM[(struct array15_field_type &)array_39(D)].dim[_269].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: Detected single element interleaving MEM[(struct array15_field_type &)array_39(D)].dim[_269].stride step 24
gnu_opt_report.txt:field_mod.f90:1362:0: note: init: stmt relevant? _268 = MEM[(struct array15_field_type &)array_39(D)].dim[_269].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: def_stmt: _268 = MEM[(struct array15_field_type &)array_39(D)].dim[_269].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: mark relevant 5, live 0: _268 = MEM[(struct array15_field_type &)array_39(D)].dim[_269].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: worklist: examine stmt: _268 = MEM[(struct array15_field_type &)array_39(D)].dim[_269].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: ==> examining statement: _268 = MEM[(struct array15_field_type &)array_39(D)].dim[_269].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note:   based on:     _268 = MEM[(struct array15_field_type &)array_39(D)].dim[_269].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: can't force alignment of ref: MEM[(struct array15_field_type &)array_39(D)].dim[_269].stride
gnu_opt_report.txt:field_mod.f90:1362:0: note: ==> examining statement: _268 = MEM[(struct array15_field_type &)array_39(D)].dim[_269].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: vect_is_simple_use: operand MEM[(struct array15_field_type &)array_39(D)].dim[_269].stride
gnu_opt_report.txt:field_mod.f90:1362:0: note: vect_is_simple_use: operand MEM[(struct array15_field_type &)array_39(D)].dim[_269].stride
gnu_opt_report.txt:field_mod.f90:1362:0: note: def_stmt: _268 = MEM[(struct array15_field_type &)array_39(D)].dim[_269].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: pretmp_256 = MEM[(struct array15_field_type &)array_39(D)].dtype.rank;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access pretmp_256 = MEM[(struct array15_field_type &)array_39(D)].dtype.rank;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _245 = MEM[(struct array15_field_type &)array_39(D)].dim[_207].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _245 = MEM[(struct array15_field_type &)array_39(D)].dim[_207].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _186 = MEM[(struct array15_field_type &)array_39(D)].dim[_187].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _186 = MEM[(struct array15_field_type &)array_39(D)].dim[_187].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _180 = MEM[(struct array15_field_type &)array_39(D)].dim[_181].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _180 = MEM[(struct array15_field_type &)array_39(D)].dim[_181].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _174 = MEM[(struct array15_field_type &)array_39(D)].dim[_175].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _174 = MEM[(struct array15_field_type &)array_39(D)].dim[_175].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _168 = MEM[(struct array15_field_type &)array_39(D)].dim[_169].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _168 = MEM[(struct array15_field_type &)array_39(D)].dim[_169].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _162 = MEM[(struct array15_field_type &)array_39(D)].dim[_163].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _162 = MEM[(struct array15_field_type &)array_39(D)].dim[_163].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _156 = MEM[(struct array15_field_type &)array_39(D)].dim[_157].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _156 = MEM[(struct array15_field_type &)array_39(D)].dim[_157].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _148 = MEM[(struct array15_field_type &)array_39(D)].dim[_149].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _148 = MEM[(struct array15_field_type &)array_39(D)].dim[_149].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _118 = MEM[(struct array15_field_type &)array_39(D)].dim[_136].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _118 = MEM[(struct array15_field_type &)array_39(D)].dim[_136].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _34 = MEM[(struct array15_field_type &)array_39(D)].dim[_83].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _34 = MEM[(struct array15_field_type &)array_39(D)].dim[_83].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _28 = MEM[(struct array15_field_type &)array_39(D)].dim[_29].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _28 = MEM[(struct array15_field_type &)array_39(D)].dim[_29].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _296 = MEM[(struct array15_field_type &)array_39(D)].dim[_297].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _296 = MEM[(struct array15_field_type &)array_39(D)].dim[_297].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _281 = MEM[(struct array15_field_type &)array_39(D)].dim[_283].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _281 = MEM[(struct array15_field_type &)array_39(D)].dim[_283].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _240 = MEM[(struct array15_field_type &)array_39(D)].dim[_246].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _240 = MEM[(struct array15_field_type &)array_39(D)].dim[_246].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _58 = MEM[(struct array15_field_type &)array_39(D)].dim[_15].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _58 = MEM[(struct array15_field_type &)array_39(D)].dim[_15].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _75 = MEM[(struct array15_field_type &)array_39(D)].dim[_74].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _75 = MEM[(struct array15_field_type &)array_39(D)].dim[_74].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _268 = MEM[(struct array15_field_type &)array_39(D)].dim[_269].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _268 = MEM[(struct array15_field_type &)array_39(D)].dim[_269].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _87 = MEM[(struct array15_field_type *)array_39(D)].dim[_84].ubound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _88 = MEM[(struct array15_field_type *)array_39(D)].dim[_84].lbound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: Detected interleaving load MEM[(struct array15_field_type *)array_39(D)].dim[_84].lbound and MEM[(struct array15_field_type *)array_39(D)].dim[_84].ubound
gnu_opt_report.txt:field_mod.f90:1362:0: note: Detected interleaving load of size 2 starting with _88 = MEM[(struct array15_field_type *)array_39(D)].dim[_84].lbound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _111 = MEM[(struct array15_field_type &)array_39(D)].data;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: pretmp_294 = MEM[(struct array15_field_type &)array_39(D)].dtype.rank;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: pretmp_257 = MEM[(struct array15_field_type &)array_39(D)].dtype.rank;
gnu_opt_report.txt:field_mod.f90:243:0: note: got vectype for stmt: self.field_type.halo.data = 0B;
gnu_opt_report.txt:field_mod.f90:243:0: note: got vectype for stmt: self.field_type.grid = grid_58(D);
gnu_opt_report.txt:field_mod.f90:243:0: note: got vectype for stmt: self.field_type.data_on_device = 0;
gnu_opt_report.txt:field_mod.f90:243:0: note: not consecutive access self.field_type.data_on_device = 0;
gnu_opt_report.txt:field_mod.f90:243:0: note: not consecutive access self.field_type.grid = grid_58(D);
gnu_opt_report.txt:field_mod.f90:243:0: note: not consecutive access self.field_type.halo.data = 0B;
gnu_opt_report.txt:field_mod.f90:317:0: note: got vectype for stmt: MEM[(struct field_type *)&self].defined_on = 0;
gnu_opt_report.txt:field_mod.f90:317:0: note: not consecutive access MEM[(struct field_type *)&self].defined_on = 0;
gnu_opt_report.txt:field_mod.f90:969:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstart = pretmp_1875;
gnu_opt_report.txt:field_mod.f90:969:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstop = pretmp_1876;
gnu_opt_report.txt:field_mod.f90:969:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystart = pretmp_1877;
gnu_opt_report.txt:field_mod.f90:969:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystop = pretmp_1878;
gnu_opt_report.txt:field_mod.f90:969:0: note: got vectype for stmt: MEM[(struct field_type *)&self].num_halos = 2;
gnu_opt_report.txt:field_mod.f90:969:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:969:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystart
gnu_opt_report.txt:field_mod.f90:969:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:969:0: note: Detected interleaving store of size 4 starting with MEM[(struct field_type *)&self].internal.xstart = pretmp_1875;
gnu_opt_report.txt:field_mod.f90:969:0: note: not consecutive access MEM[(struct field_type *)&self].num_halos = 2;
gnu_opt_report.txt:field_mod.f90:969:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstart = pretmp_1875;
gnu_opt_report.txt:field_mod.f90:969:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstop = pretmp_1876;
gnu_opt_report.txt:field_mod.f90:969:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystart = pretmp_1877;
gnu_opt_report.txt:field_mod.f90:969:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystop = pretmp_1878;
gnu_opt_report.txt:field_mod.f90:969:0: note: 	stmt 0 MEM[(struct field_type *)&self].internal.xstart = pretmp_1875;
gnu_opt_report.txt:field_mod.f90:969:0: note: 	stmt 1 MEM[(struct field_type *)&self].internal.xstop = pretmp_1876;
gnu_opt_report.txt:field_mod.f90:969:0: note: 	stmt 2 MEM[(struct field_type *)&self].internal.ystart = pretmp_1877;
gnu_opt_report.txt:field_mod.f90:969:0: note: 	stmt 3 MEM[(struct field_type *)&self].internal.ystop = pretmp_1878;
gnu_opt_report.txt:field_mod.f90:969:0: note:   based on:     MEM[(struct field_type *)&self].internal.xstart = pretmp_1875;
gnu_opt_report.txt:field_mod.f90:969:0: note: misalign = 8 bytes of ref MEM[(struct field_type *)&self].internal.xstart
gnu_opt_report.txt:field_mod.f90:969:0: note: ==> examining statement: MEM[(struct field_type *)&self].internal.xstart = pretmp_1875;
gnu_opt_report.txt:field_mod.f90:969:0: note: ------>vectorizing SLP node starting from: MEM[(struct field_type *)&self].internal.xstart = pretmp_1875;
gnu_opt_report.txt:field_mod.f90:969:0: note: create vector_type-pointer variable to type: vector(4) integer(kind=4)  vectorizing a pointer ref: MEM[(struct field_type *)&self].internal.xstart
gnu_opt_report.txt:field_mod.f90:969:0: note: created &MEM[(struct field_type *)&self].internal.xstart
gnu_opt_report.txt:field_mod.f90:967:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstart = _366;
gnu_opt_report.txt:field_mod.f90:967:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstop = pretmp_1876;
gnu_opt_report.txt:field_mod.f90:967:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystart = pretmp_1877;
gnu_opt_report.txt:field_mod.f90:967:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystop = pretmp_1878;
gnu_opt_report.txt:field_mod.f90:967:0: note: got vectype for stmt: MEM[(struct field_type *)&self].num_halos = 0;
gnu_opt_report.txt:field_mod.f90:967:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:967:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystart
gnu_opt_report.txt:field_mod.f90:967:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:967:0: note: Detected interleaving store of size 4 starting with MEM[(struct field_type *)&self].internal.xstart = _366;
gnu_opt_report.txt:field_mod.f90:967:0: note: not consecutive access MEM[(struct field_type *)&self].num_halos = 0;
gnu_opt_report.txt:field_mod.f90:967:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstart = _366;
gnu_opt_report.txt:field_mod.f90:967:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstop = pretmp_1876;
gnu_opt_report.txt:field_mod.f90:967:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystart = pretmp_1877;
gnu_opt_report.txt:field_mod.f90:967:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystop = pretmp_1878;
gnu_opt_report.txt:field_mod.f90:967:0: note:   based on:     MEM[(struct field_type *)&self].internal.xstart = _366;
gnu_opt_report.txt:field_mod.f90:972:0: note: got vectype for stmt: MEM[(struct field_type *)&self].num_halos = prephitmp_1880;
gnu_opt_report.txt:field_mod.f90:975:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dtype.elem_len = 52;
gnu_opt_report.txt:field_mod.f90:975:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dtype.rank = 1;
gnu_opt_report.txt:field_mod.f90:975:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dtype.type = 5;
gnu_opt_report.txt:field_mod.f90:975:0: note: Detected interleaving store MEM[(struct field_type *)&self].halo.dtype.rank and MEM[(struct field_type *)&self].halo.dtype.type
gnu_opt_report.txt:field_mod.f90:975:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].halo.dtype.rank = 1;
gnu_opt_report.txt:field_mod.f90:975:0: note: not consecutive access MEM[(struct field_type *)&self].halo.dtype.elem_len = 52;
gnu_opt_report.txt:field_mod.f90:975:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dtype.rank = 1;
gnu_opt_report.txt:field_mod.f90:975:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.data = _387;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dim[0].lbound = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dim[0].ubound = _392;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dim[0].stride = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.offset = -1;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving store MEM[(struct field_type *)&self].halo.span and MEM[(struct field_type *)&self].halo.dim[0].stride
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving store MEM[(struct field_type *)&self].halo.span and MEM[(struct field_type *)&self].halo.dim[0].lbound
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving store MEM[(struct field_type *)&self].halo.span and MEM[(struct field_type *)&self].halo.dim[0].ubound
gnu_opt_report.txt:field_mod.f90:978:0: note: not consecutive access MEM[(struct field_type *)&self].halo.offset = -1;
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving store of size 4 starting with MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dim[0].stride = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dim[0].lbound = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dim[0].ubound = _392;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP failed: different operation in stmt MEM[(struct field_type *)&self].halo.dim[0].ubound = _392;
gnu_opt_report.txt:field_mod.f90:978:0: note: original stmt MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dim[0].stride = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: 	stmt 0 MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: 	stmt 1 MEM[(struct field_type *)&self].halo.dim[0].stride = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note:   based on:     MEM[(struct field_type *)&self].halo.dim[0].lbound = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: misalign = 8 bytes of ref MEM[(struct field_type *)&self].halo.span
gnu_opt_report.txt:field_mod.f90:978:0: note: ==> examining statement: MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: ------>vectorizing SLP node starting from: MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: create vector_type-pointer variable to type: vector(2) integer(kind=8)  vectorizing a pointer ref: MEM[(struct field_type *)&self].halo.span
gnu_opt_report.txt:field_mod.f90:978:0: note: created &MEM[(struct field_type *)&self].halo.span
gnu_opt_report.txt:field_mod.f90:1004:0: note: got vectype for stmt: pretmp_1543 = MEM[(struct field_type *)&self].internal.ystop;
gnu_opt_report.txt:field_mod.f90:1004:0: note: got vectype for stmt: pretmp_1557 = MEM[(struct field_type *)&self].internal.ystart;
gnu_opt_report.txt:field_mod.f90:1004:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.ystart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:1004:0: note: Detected interleaving load of size 2 starting with pretmp_1557 = MEM[(struct field_type *)&self].internal.ystart;
gnu_opt_report.txt:field_mod.f90:1027:0: note: got vectype for stmt: pretmp_1544 = MEM[(struct field_type *)&self].internal.ystop;
gnu_opt_report.txt:field_mod.f90:1027:0: note: got vectype for stmt: pretmp_1558 = MEM[(struct field_type *)&self].internal.ystart;
gnu_opt_report.txt:field_mod.f90:1027:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.ystart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:1027:0: note: Detected interleaving load of size 2 starting with pretmp_1558 = MEM[(struct field_type *)&self].internal.ystart;
gnu_opt_report.txt:field_mod.f90:1027:0: note:   based on:     pretmp_1544 = MEM[(struct field_type *)&self].internal.ystop;
gnu_opt_report.txt:field_mod.f90:455:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstart = _417;
gnu_opt_report.txt:field_mod.f90:455:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstop = _419;
gnu_opt_report.txt:field_mod.f90:455:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:455:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].internal.xstart = _417;
gnu_opt_report.txt:field_mod.f90:455:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstart = _417;
gnu_opt_report.txt:field_mod.f90:455:0: note:   based on:     MEM[(struct field_type *)&self].internal.xstart = _417;
gnu_opt_report.txt:field_mod.f90:461:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystart = _423;
gnu_opt_report.txt:field_mod.f90:461:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystop = _424;
gnu_opt_report.txt:field_mod.f90:461:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.ystart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:461:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].internal.ystart = _423;
gnu_opt_report.txt:field_mod.f90:461:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystart = _423;
gnu_opt_report.txt:field_mod.f90:461:0: note:   based on:     MEM[(struct field_type *)&self].internal.ystart = _423;
gnu_opt_report.txt:field_mod.f90:463:0: note: got vectype for stmt: pretmp_1868 = MEM[(struct field_type *)&self].internal.ystop;
gnu_opt_report.txt:field_mod.f90:463:0: note: got vectype for stmt: pretmp_1870 = MEM[(struct field_type *)&self].internal.ystart;
gnu_opt_report.txt:field_mod.f90:463:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.ystart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:463:0: note: Detected interleaving load of size 2 starting with pretmp_1870 = MEM[(struct field_type *)&self].internal.ystart;
gnu_opt_report.txt:field_mod.f90:467:0: note: got vectype for stmt: MEM[(struct field_type *)&self].num_halos = 0;
gnu_opt_report.txt:field_mod.f90:467:0: note: got vectype for stmt: pretmp_1506 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:467:0: note: got vectype for stmt: pretmp_1520 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:467:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:467:0: note: Detected interleaving load of size 2 starting with pretmp_1520 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:467:0: note: not consecutive access MEM[(struct field_type *)&self].num_halos = 0;
gnu_opt_report.txt:field_mod.f90:317:0: note: got vectype for stmt: pretmp_1517 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:317:0: note: got vectype for stmt: pretmp_1531 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:317:0: note: got vectype for stmt: pretmp_1545 = MEM[(struct field_type *)&self].internal.ystop;
gnu_opt_report.txt:field_mod.f90:317:0: note: got vectype for stmt: pretmp_1559 = MEM[(struct field_type *)&self].internal.ystart;
gnu_opt_report.txt:field_mod.f90:317:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:317:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystart
gnu_opt_report.txt:field_mod.f90:317:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:317:0: note: Detected interleaving load of size 4 starting with pretmp_1531 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:488:0: note: got vectype for stmt: MEM[(struct field_type *)&self].defined_on = 1;
gnu_opt_report.txt:field_mod.f90:488:0: note: not consecutive access MEM[(struct field_type *)&self].defined_on = 1;
gnu_opt_report.txt:field_mod.f90:509:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstart = pretmp_1826;
gnu_opt_report.txt:field_mod.f90:509:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstop = pretmp_1827;
gnu_opt_report.txt:field_mod.f90:509:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystart = pretmp_1824;
gnu_opt_report.txt:field_mod.f90:509:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystop = pretmp_1825;
gnu_opt_report.txt:field_mod.f90:509:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:509:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystart
gnu_opt_report.txt:field_mod.f90:509:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:509:0: note: Detected interleaving store of size 4 starting with MEM[(struct field_type *)&self].internal.xstart = pretmp_1826;
gnu_opt_report.txt:field_mod.f90:509:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstart = pretmp_1826;
gnu_opt_report.txt:field_mod.f90:509:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstop = pretmp_1827;
gnu_opt_report.txt:field_mod.f90:509:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystart = pretmp_1824;
gnu_opt_report.txt:field_mod.f90:509:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystop = pretmp_1825;
gnu_opt_report.txt:field_mod.f90:509:0: note: 	stmt 0 MEM[(struct field_type *)&self].internal.xstart = pretmp_1826;
gnu_opt_report.txt:field_mod.f90:509:0: note: 	stmt 1 MEM[(struct field_type *)&self].internal.xstop = pretmp_1827;
gnu_opt_report.txt:field_mod.f90:509:0: note: 	stmt 2 MEM[(struct field_type *)&self].internal.ystart = pretmp_1824;
gnu_opt_report.txt:field_mod.f90:509:0: note: 	stmt 3 MEM[(struct field_type *)&self].internal.ystop = pretmp_1825;
gnu_opt_report.txt:field_mod.f90:509:0: note:   based on:     MEM[(struct field_type *)&self].internal.xstart = pretmp_1826;
gnu_opt_report.txt:field_mod.f90:509:0: note: misalign = 8 bytes of ref MEM[(struct field_type *)&self].internal.xstart
gnu_opt_report.txt:field_mod.f90:509:0: note: ==> examining statement: MEM[(struct field_type *)&self].internal.xstart = pretmp_1826;
gnu_opt_report.txt:field_mod.f90:509:0: note: ------>vectorizing SLP node starting from: MEM[(struct field_type *)&self].internal.xstart = pretmp_1826;
gnu_opt_report.txt:field_mod.f90:509:0: note: create vector_type-pointer variable to type: vector(4) integer(kind=4)  vectorizing a pointer ref: MEM[(struct field_type *)&self].internal.xstart
gnu_opt_report.txt:field_mod.f90:509:0: note: created &MEM[(struct field_type *)&self].internal.xstart
gnu_opt_report.txt:field_mod.f90:527:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstart = pretmp_1826;
gnu_opt_report.txt:field_mod.f90:527:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstop = pretmp_1827;
gnu_opt_report.txt:field_mod.f90:527:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystart = _439;
gnu_opt_report.txt:field_mod.f90:527:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystop = pretmp_1825;
gnu_opt_report.txt:field_mod.f90:527:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:527:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystart
gnu_opt_report.txt:field_mod.f90:527:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:527:0: note: Detected interleaving store of size 4 starting with MEM[(struct field_type *)&self].internal.xstart = pretmp_1826;
gnu_opt_report.txt:field_mod.f90:527:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstart = pretmp_1826;
gnu_opt_report.txt:field_mod.f90:527:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstop = pretmp_1827;
gnu_opt_report.txt:field_mod.f90:527:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystart = _439;
gnu_opt_report.txt:field_mod.f90:527:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystop = pretmp_1825;
gnu_opt_report.txt:field_mod.f90:527:0: note:   based on:     MEM[(struct field_type *)&self].internal.xstart = pretmp_1826;
gnu_opt_report.txt:field_mod.f90:968:0: note: got vectype for stmt: MEM[(struct field_type *)&self].num_halos = 0;
gnu_opt_report.txt:field_mod.f90:968:0: note: not consecutive access MEM[(struct field_type *)&self].num_halos = 0;
gnu_opt_report.txt:field_mod.f90:969:0: note: got vectype for stmt: MEM[(struct field_type *)&self].num_halos = 2;
gnu_opt_report.txt:field_mod.f90:972:0: note: got vectype for stmt: MEM[(struct field_type *)&self].num_halos = prephitmp_1835;
gnu_opt_report.txt:field_mod.f90:975:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dtype.elem_len = 52;
gnu_opt_report.txt:field_mod.f90:975:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dtype.rank = 1;
gnu_opt_report.txt:field_mod.f90:975:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dtype.type = 5;
gnu_opt_report.txt:field_mod.f90:975:0: note: Detected interleaving store MEM[(struct field_type *)&self].halo.dtype.rank and MEM[(struct field_type *)&self].halo.dtype.type
gnu_opt_report.txt:field_mod.f90:975:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].halo.dtype.rank = 1;
gnu_opt_report.txt:field_mod.f90:975:0: note: not consecutive access MEM[(struct field_type *)&self].halo.dtype.elem_len = 52;
gnu_opt_report.txt:field_mod.f90:975:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dtype.rank = 1;
gnu_opt_report.txt:field_mod.f90:975:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.data = _458;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dim[0].lbound = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dim[0].ubound = _463;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dim[0].stride = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.offset = -1;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving store MEM[(struct field_type *)&self].halo.span and MEM[(struct field_type *)&self].halo.dim[0].stride
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving store MEM[(struct field_type *)&self].halo.span and MEM[(struct field_type *)&self].halo.dim[0].lbound
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving store MEM[(struct field_type *)&self].halo.span and MEM[(struct field_type *)&self].halo.dim[0].ubound
gnu_opt_report.txt:field_mod.f90:978:0: note: not consecutive access MEM[(struct field_type *)&self].halo.offset = -1;
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving store of size 4 starting with MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dim[0].stride = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dim[0].lbound = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dim[0].ubound = _463;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP failed: different operation in stmt MEM[(struct field_type *)&self].halo.dim[0].ubound = _463;
gnu_opt_report.txt:field_mod.f90:978:0: note: original stmt MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dim[0].stride = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: 	stmt 0 MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: 	stmt 1 MEM[(struct field_type *)&self].halo.dim[0].stride = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note:   based on:     MEM[(struct field_type *)&self].halo.dim[0].lbound = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: misalign = 8 bytes of ref MEM[(struct field_type *)&self].halo.span
gnu_opt_report.txt:field_mod.f90:978:0: note: ==> examining statement: MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: ------>vectorizing SLP node starting from: MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: create vector_type-pointer variable to type: vector(2) integer(kind=8)  vectorizing a pointer ref: MEM[(struct field_type *)&self].halo.span
gnu_opt_report.txt:field_mod.f90:978:0: note: created &MEM[(struct field_type *)&self].halo.span
gnu_opt_report.txt:field_mod.f90:589:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstart = _488;
gnu_opt_report.txt:field_mod.f90:589:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstop = _489;
gnu_opt_report.txt:field_mod.f90:589:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:589:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].internal.xstart = _488;
gnu_opt_report.txt:field_mod.f90:589:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstart = _488;
gnu_opt_report.txt:field_mod.f90:589:0: note:   based on:     MEM[(struct field_type *)&self].internal.xstart = _488;
gnu_opt_report.txt:field_mod.f90:596:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystart = _493;
gnu_opt_report.txt:field_mod.f90:596:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystop = _495;
gnu_opt_report.txt:field_mod.f90:596:0: note: got vectype for stmt: pretmp_1515 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:596:0: note: got vectype for stmt: pretmp_1529 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:596:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:596:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.ystart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:596:0: note: Detected interleaving load of size 2 starting with pretmp_1529 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:596:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].internal.ystart = _493;
gnu_opt_report.txt:field_mod.f90:596:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystart = _493;
gnu_opt_report.txt:field_mod.f90:596:0: note:   based on:     MEM[(struct field_type *)&self].internal.ystart = _493;
gnu_opt_report.txt:field_mod.f90:598:0: note: got vectype for stmt: pretmp_1507 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:598:0: note: got vectype for stmt: pretmp_1521 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:598:0: note: got vectype for stmt: pretmp_1535 = MEM[(struct field_type *)&self].internal.ystop;
gnu_opt_report.txt:field_mod.f90:598:0: note: got vectype for stmt: pretmp_1549 = MEM[(struct field_type *)&self].internal.ystart;
gnu_opt_report.txt:field_mod.f90:598:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:598:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystart
gnu_opt_report.txt:field_mod.f90:598:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:598:0: note: Detected interleaving load of size 4 starting with pretmp_1521 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:488:0: note: got vectype for stmt: pretmp_1514 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:488:0: note: got vectype for stmt: pretmp_1528 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:488:0: note: got vectype for stmt: pretmp_1542 = MEM[(struct field_type *)&self].internal.ystop;
gnu_opt_report.txt:field_mod.f90:488:0: note: got vectype for stmt: pretmp_1556 = MEM[(struct field_type *)&self].internal.ystart;
gnu_opt_report.txt:field_mod.f90:488:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:488:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystart
gnu_opt_report.txt:field_mod.f90:488:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:488:0: note: Detected interleaving load of size 4 starting with pretmp_1528 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:620:0: note: got vectype for stmt: MEM[(struct field_type *)&self].defined_on = 2;
gnu_opt_report.txt:field_mod.f90:620:0: note: not consecutive access MEM[(struct field_type *)&self].defined_on = 2;
gnu_opt_report.txt:field_mod.f90:968:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstart = _501;
gnu_opt_report.txt:field_mod.f90:968:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstop = _502;
gnu_opt_report.txt:field_mod.f90:968:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystart = _503;
gnu_opt_report.txt:field_mod.f90:968:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystop = _504;
gnu_opt_report.txt:field_mod.f90:968:0: note: got vectype for stmt: MEM[(struct field_type *)&self].num_halos = 0;
gnu_opt_report.txt:field_mod.f90:968:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:968:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystart
gnu_opt_report.txt:field_mod.f90:968:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:968:0: note: Detected interleaving store of size 4 starting with MEM[(struct field_type *)&self].internal.xstart = _501;
gnu_opt_report.txt:field_mod.f90:968:0: note: not consecutive access MEM[(struct field_type *)&self].num_halos = 0;
gnu_opt_report.txt:field_mod.f90:968:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstart = _501;
gnu_opt_report.txt:field_mod.f90:968:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstop = _502;
gnu_opt_report.txt:field_mod.f90:968:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystart = _503;
gnu_opt_report.txt:field_mod.f90:968:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystop = _504;
gnu_opt_report.txt:field_mod.f90:968:0: note: 	stmt 0 MEM[(struct field_type *)&self].internal.xstart = _501;
gnu_opt_report.txt:field_mod.f90:968:0: note: 	stmt 1 MEM[(struct field_type *)&self].internal.xstop = _502;
gnu_opt_report.txt:field_mod.f90:968:0: note: 	stmt 2 MEM[(struct field_type *)&self].internal.ystart = _503;
gnu_opt_report.txt:field_mod.f90:968:0: note: 	stmt 3 MEM[(struct field_type *)&self].internal.ystop = _504;
gnu_opt_report.txt:field_mod.f90:968:0: note:   based on:     MEM[(struct field_type *)&self].internal.xstart = _501;
gnu_opt_report.txt:field_mod.f90:968:0: note: misalign = 8 bytes of ref MEM[(struct field_type *)&self].internal.xstart
gnu_opt_report.txt:field_mod.f90:968:0: note: ==> examining statement: MEM[(struct field_type *)&self].internal.xstart = _501;
gnu_opt_report.txt:field_mod.f90:968:0: note: ------>vectorizing SLP node starting from: MEM[(struct field_type *)&self].internal.xstart = _501;
gnu_opt_report.txt:field_mod.f90:968:0: note: create vector_type-pointer variable to type: vector(4) integer(kind=4)  vectorizing a pointer ref: MEM[(struct field_type *)&self].internal.xstart
gnu_opt_report.txt:field_mod.f90:968:0: note: created &MEM[(struct field_type *)&self].internal.xstart
gnu_opt_report.txt:field_mod.f90:969:0: note: got vectype for stmt: MEM[(struct field_type *)&self].num_halos = 2;
gnu_opt_report.txt:field_mod.f90:972:0: note: got vectype for stmt: MEM[(struct field_type *)&self].num_halos = prephitmp_1796;
gnu_opt_report.txt:field_mod.f90:975:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dtype.elem_len = 52;
gnu_opt_report.txt:field_mod.f90:975:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dtype.rank = 1;
gnu_opt_report.txt:field_mod.f90:975:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dtype.type = 5;
gnu_opt_report.txt:field_mod.f90:975:0: note: Detected interleaving store MEM[(struct field_type *)&self].halo.dtype.rank and MEM[(struct field_type *)&self].halo.dtype.type
gnu_opt_report.txt:field_mod.f90:975:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].halo.dtype.rank = 1;
gnu_opt_report.txt:field_mod.f90:975:0: note: not consecutive access MEM[(struct field_type *)&self].halo.dtype.elem_len = 52;
gnu_opt_report.txt:field_mod.f90:975:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dtype.rank = 1;
gnu_opt_report.txt:field_mod.f90:975:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.data = _522;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dim[0].lbound = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dim[0].ubound = _527;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dim[0].stride = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.offset = -1;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving store MEM[(struct field_type *)&self].halo.span and MEM[(struct field_type *)&self].halo.dim[0].stride
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving store MEM[(struct field_type *)&self].halo.span and MEM[(struct field_type *)&self].halo.dim[0].lbound
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving store MEM[(struct field_type *)&self].halo.span and MEM[(struct field_type *)&self].halo.dim[0].ubound
gnu_opt_report.txt:field_mod.f90:978:0: note: not consecutive access MEM[(struct field_type *)&self].halo.offset = -1;
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving store of size 4 starting with MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dim[0].stride = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dim[0].lbound = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dim[0].ubound = _527;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP failed: different operation in stmt MEM[(struct field_type *)&self].halo.dim[0].ubound = _527;
gnu_opt_report.txt:field_mod.f90:978:0: note: original stmt MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dim[0].stride = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: 	stmt 0 MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: 	stmt 1 MEM[(struct field_type *)&self].halo.dim[0].stride = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note:   based on:     MEM[(struct field_type *)&self].halo.dim[0].lbound = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: misalign = 8 bytes of ref MEM[(struct field_type *)&self].halo.span
gnu_opt_report.txt:field_mod.f90:978:0: note: ==> examining statement: MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: ------>vectorizing SLP node starting from: MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: create vector_type-pointer variable to type: vector(2) integer(kind=8)  vectorizing a pointer ref: MEM[(struct field_type *)&self].halo.span
gnu_opt_report.txt:field_mod.f90:978:0: note: created &MEM[(struct field_type *)&self].halo.span
gnu_opt_report.txt:field_mod.f90:692:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstart = _552;
gnu_opt_report.txt:field_mod.f90:692:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstop = _553;
gnu_opt_report.txt:field_mod.f90:692:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:692:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].internal.xstart = _552;
gnu_opt_report.txt:field_mod.f90:692:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstart = _552;
gnu_opt_report.txt:field_mod.f90:692:0: note:   based on:     MEM[(struct field_type *)&self].internal.xstart = _552;
gnu_opt_report.txt:field_mod.f90:701:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystart = _557;
gnu_opt_report.txt:field_mod.f90:701:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystop = _558;
gnu_opt_report.txt:field_mod.f90:701:0: note: got vectype for stmt: pretmp_1512 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:701:0: note: got vectype for stmt: pretmp_1526 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:701:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:701:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.ystart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:701:0: note: Detected interleaving load of size 2 starting with pretmp_1526 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:701:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].internal.ystart = _557;
gnu_opt_report.txt:field_mod.f90:701:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystart = _557;
gnu_opt_report.txt:field_mod.f90:701:0: note:   based on:     MEM[(struct field_type *)&self].internal.ystart = _557;
gnu_opt_report.txt:field_mod.f90:703:0: note: got vectype for stmt: pretmp_1508 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:703:0: note: got vectype for stmt: pretmp_1522 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:703:0: note: got vectype for stmt: pretmp_1536 = MEM[(struct field_type *)&self].internal.ystop;
gnu_opt_report.txt:field_mod.f90:703:0: note: got vectype for stmt: pretmp_1550 = MEM[(struct field_type *)&self].internal.ystart;
gnu_opt_report.txt:field_mod.f90:703:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:703:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystart
gnu_opt_report.txt:field_mod.f90:703:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:703:0: note: Detected interleaving load of size 4 starting with pretmp_1522 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:620:0: note: got vectype for stmt: pretmp_1511 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:620:0: note: got vectype for stmt: pretmp_1525 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:620:0: note: got vectype for stmt: pretmp_1540 = MEM[(struct field_type *)&self].internal.ystop;
gnu_opt_report.txt:field_mod.f90:620:0: note: got vectype for stmt: pretmp_1554 = MEM[(struct field_type *)&self].internal.ystart;
gnu_opt_report.txt:field_mod.f90:620:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:620:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystart
gnu_opt_report.txt:field_mod.f90:620:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:620:0: note: Detected interleaving load of size 4 starting with pretmp_1525 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:725:0: note: got vectype for stmt: MEM[(struct field_type *)&self].defined_on = 3;
gnu_opt_report.txt:field_mod.f90:725:0: note: not consecutive access MEM[(struct field_type *)&self].defined_on = 3;
gnu_opt_report.txt:field_mod.f90:748:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstart = pretmp_1745;
gnu_opt_report.txt:field_mod.f90:748:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstop = _568;
gnu_opt_report.txt:field_mod.f90:748:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:748:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].internal.xstart = pretmp_1745;
gnu_opt_report.txt:field_mod.f90:748:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstart = pretmp_1745;
gnu_opt_report.txt:field_mod.f90:748:0: note:   based on:     MEM[(struct field_type *)&self].internal.xstart = pretmp_1745;
gnu_opt_report.txt:field_mod.f90:754:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstart = _570;
gnu_opt_report.txt:field_mod.f90:754:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstop = _571;
gnu_opt_report.txt:field_mod.f90:754:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:754:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].internal.xstart = _570;
gnu_opt_report.txt:field_mod.f90:754:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstart = _570;
gnu_opt_report.txt:field_mod.f90:754:0: note:   based on:     MEM[(struct field_type *)&self].internal.xstart = _570;
gnu_opt_report.txt:field_mod.f90:759:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystart = pretmp_1759;
gnu_opt_report.txt:field_mod.f90:759:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystop = _578;
gnu_opt_report.txt:field_mod.f90:759:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.ystart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:759:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].internal.ystart = pretmp_1759;
gnu_opt_report.txt:field_mod.f90:759:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystart = pretmp_1759;
gnu_opt_report.txt:field_mod.f90:759:0: note:   based on:     MEM[(struct field_type *)&self].internal.ystart = pretmp_1759;
gnu_opt_report.txt:field_mod.f90:765:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystart = _580;
gnu_opt_report.txt:field_mod.f90:765:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystop = _581;
gnu_opt_report.txt:field_mod.f90:765:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.ystart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:765:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].internal.ystart = _580;
gnu_opt_report.txt:field_mod.f90:765:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystart = _580;
gnu_opt_report.txt:field_mod.f90:765:0: note:   based on:     MEM[(struct field_type *)&self].internal.ystart = _580;
gnu_opt_report.txt:field_mod.f90:968:0: note: got vectype for stmt: MEM[(struct field_type *)&self].num_halos = 0;
gnu_opt_report.txt:field_mod.f90:968:0: note: not consecutive access MEM[(struct field_type *)&self].num_halos = 0;
gnu_opt_report.txt:field_mod.f90:969:0: note: got vectype for stmt: MEM[(struct field_type *)&self].num_halos = 2;
gnu_opt_report.txt:field_mod.f90:972:0: note: got vectype for stmt: MEM[(struct field_type *)&self].num_halos = prephitmp_1767;
gnu_opt_report.txt:field_mod.f90:975:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dtype.elem_len = 52;
gnu_opt_report.txt:field_mod.f90:975:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dtype.rank = 1;
gnu_opt_report.txt:field_mod.f90:975:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dtype.type = 5;
gnu_opt_report.txt:field_mod.f90:975:0: note: Detected interleaving store MEM[(struct field_type *)&self].halo.dtype.rank and MEM[(struct field_type *)&self].halo.dtype.type
gnu_opt_report.txt:field_mod.f90:975:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].halo.dtype.rank = 1;
gnu_opt_report.txt:field_mod.f90:975:0: note: not consecutive access MEM[(struct field_type *)&self].halo.dtype.elem_len = 52;
gnu_opt_report.txt:field_mod.f90:975:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dtype.rank = 1;
gnu_opt_report.txt:field_mod.f90:975:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.data = _599;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dim[0].lbound = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dim[0].ubound = _604;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dim[0].stride = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.offset = -1;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: pretmp_1778 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: pretmp_1780 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving store MEM[(struct field_type *)&self].halo.span and MEM[(struct field_type *)&self].halo.dim[0].stride
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving store MEM[(struct field_type *)&self].halo.span and MEM[(struct field_type *)&self].halo.dim[0].lbound
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving store MEM[(struct field_type *)&self].halo.span and MEM[(struct field_type *)&self].halo.dim[0].ubound
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving load of size 2 starting with pretmp_1780 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:978:0: note: not consecutive access MEM[(struct field_type *)&self].halo.offset = -1;
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving store of size 4 starting with MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dim[0].stride = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dim[0].lbound = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dim[0].ubound = _604;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP failed: different operation in stmt MEM[(struct field_type *)&self].halo.dim[0].ubound = _604;
gnu_opt_report.txt:field_mod.f90:978:0: note: original stmt MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dim[0].stride = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: 	stmt 0 MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: 	stmt 1 MEM[(struct field_type *)&self].halo.dim[0].stride = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note:   based on:     MEM[(struct field_type *)&self].halo.dim[0].lbound = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: misalign = 8 bytes of ref MEM[(struct field_type *)&self].halo.span
gnu_opt_report.txt:field_mod.f90:978:0: note: ==> examining statement: MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: ------>vectorizing SLP node starting from: MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: create vector_type-pointer variable to type: vector(2) integer(kind=8)  vectorizing a pointer ref: MEM[(struct field_type *)&self].halo.span
gnu_opt_report.txt:field_mod.f90:978:0: note: created &MEM[(struct field_type *)&self].halo.span
gnu_opt_report.txt:field_mod.f90:1001:0: note: def_stmt: pretmp_1780 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:1001:0: note: def_stmt: pretmp_1780 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:1001:0: note: def_stmt: pretmp_1778 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:1001:0: note: def_stmt: pretmp_1778 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:1001:0: note: def_stmt: pretmp_1780 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:1001:0: note: def_stmt: pretmp_1780 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:1001:0: note: def_stmt: pretmp_1778 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:1001:0: note: def_stmt: pretmp_1778 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:1001:0: note: def_stmt: pretmp_1780 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:1001:0: note: def_stmt: pretmp_1778 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:1001:0: note: def_stmt: pretmp_1780 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:1001:0: note: def_stmt: pretmp_1780 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:1001:0: note: def_stmt: pretmp_1778 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:1001:0: note: def_stmt: pretmp_1778 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:821:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstart = _629;
gnu_opt_report.txt:field_mod.f90:821:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstop = _631;
gnu_opt_report.txt:field_mod.f90:821:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:821:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].internal.xstart = _629;
gnu_opt_report.txt:field_mod.f90:821:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstart = _629;
gnu_opt_report.txt:field_mod.f90:821:0: note:   based on:     MEM[(struct field_type *)&self].internal.xstart = _629;
gnu_opt_report.txt:field_mod.f90:823:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystart = _633;
gnu_opt_report.txt:field_mod.f90:823:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystop = _635;
gnu_opt_report.txt:field_mod.f90:823:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.ystart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:823:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].internal.ystart = _633;
gnu_opt_report.txt:field_mod.f90:823:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystart = _633;
gnu_opt_report.txt:field_mod.f90:823:0: note:   based on:     MEM[(struct field_type *)&self].internal.ystart = _633;
gnu_opt_report.txt:field_mod.f90:825:0: note: got vectype for stmt: pretmp_1537 = MEM[(struct field_type *)&self].internal.ystop;
gnu_opt_report.txt:field_mod.f90:825:0: note: got vectype for stmt: pretmp_1551 = MEM[(struct field_type *)&self].internal.ystart;
gnu_opt_report.txt:field_mod.f90:825:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.ystart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:825:0: note: Detected interleaving load of size 2 starting with pretmp_1551 = MEM[(struct field_type *)&self].internal.ystart;
gnu_opt_report.txt:field_mod.f90:725:0: note: got vectype for stmt: pretmp_1510 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:725:0: note: got vectype for stmt: pretmp_1524 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:725:0: note: got vectype for stmt: pretmp_1539 = MEM[(struct field_type *)&self].internal.ystop;
gnu_opt_report.txt:field_mod.f90:725:0: note: got vectype for stmt: pretmp_1553 = MEM[(struct field_type *)&self].internal.ystart;
gnu_opt_report.txt:field_mod.f90:725:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:725:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystart
gnu_opt_report.txt:field_mod.f90:725:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:725:0: note: Detected interleaving load of size 4 starting with pretmp_1524 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:296:0: note: got vectype for stmt: MEM[(struct field_type *)&self].defined_on = 4;
gnu_opt_report.txt:field_mod.f90:296:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstart = 1;
gnu_opt_report.txt:field_mod.f90:296:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstop = m_326;
gnu_opt_report.txt:field_mod.f90:296:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystart = 1;
gnu_opt_report.txt:field_mod.f90:296:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystop = n_327;
gnu_opt_report.txt:field_mod.f90:296:0: note: got vectype for stmt: MEM[(struct field_type *)&self].num_halos = 0;
gnu_opt_report.txt:field_mod.f90:296:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:296:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystart
gnu_opt_report.txt:field_mod.f90:296:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:296:0: note: not consecutive access MEM[(struct field_type *)&self].defined_on = 4;
gnu_opt_report.txt:field_mod.f90:296:0: note: Detected interleaving store of size 4 starting with MEM[(struct field_type *)&self].internal.xstart = 1;
gnu_opt_report.txt:field_mod.f90:296:0: note: not consecutive access MEM[(struct field_type *)&self].num_halos = 0;
gnu_opt_report.txt:field_mod.f90:296:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstart = 1;
gnu_opt_report.txt:field_mod.f90:296:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstop = m_326;
gnu_opt_report.txt:field_mod.f90:296:0: note: Build SLP failed: different operation in stmt MEM[(struct field_type *)&self].internal.xstop = m_326;
gnu_opt_report.txt:field_mod.f90:296:0: note: original stmt MEM[(struct field_type *)&self].internal.xstart = 1;
gnu_opt_report.txt:field_mod.f90:296:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystart = 1;
gnu_opt_report.txt:field_mod.f90:296:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystop = n_327;
gnu_opt_report.txt:field_mod.f90:296:0: note: Build SLP failed: different operation in stmt MEM[(struct field_type *)&self].internal.ystop = n_327;
gnu_opt_report.txt:field_mod.f90:296:0: note: original stmt MEM[(struct field_type *)&self].internal.xstart = 1;
gnu_opt_report.txt:field_mod.f90:296:0: note:   based on:     MEM[(struct field_type *)&self].defined_on = 4;
gnu_opt_report.txt:field_mod.f90:243:0: note: got vectype for stmt: pretmp_1509 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:243:0: note: got vectype for stmt: pretmp_1523 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:243:0: note: got vectype for stmt: pretmp_1538 = MEM[(struct field_type *)&self].internal.ystop;
gnu_opt_report.txt:field_mod.f90:243:0: note: got vectype for stmt: pretmp_1552 = MEM[(struct field_type *)&self].internal.ystart;
gnu_opt_report.txt:field_mod.f90:243:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:243:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystart
gnu_opt_report.txt:field_mod.f90:243:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:243:0: note: Detected interleaving load of size 4 starting with pretmp_1523 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:1340:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.nx = _332;
gnu_opt_report.txt:field_mod.f90:1340:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ny = _336;
gnu_opt_report.txt:field_mod.f90:1340:0: note: got vectype for stmt: MEM[(struct field_type *)&self].whole.xstop = prephitmp_1609;
gnu_opt_report.txt:field_mod.f90:1340:0: note: got vectype for stmt: MEM[(struct field_type *)&self].whole.xstart = prephitmp_1593;
gnu_opt_report.txt:field_mod.f90:1340:0: note: got vectype for stmt: MEM[(struct field_type *)&self].whole.ystop = prephitmp_1655;
gnu_opt_report.txt:field_mod.f90:1340:0: note: got vectype for stmt: MEM[(struct field_type *)&self].whole.ystart = prephitmp_1638;
gnu_opt_report.txt:field_mod.f90:1340:0: note: got vectype for stmt: MEM[(struct field_type *)&self].whole.nx = _352;
gnu_opt_report.txt:field_mod.f90:1340:0: note: got vectype for stmt: MEM[(struct field_type *)&self].whole.ny = _356;
gnu_opt_report.txt:field_mod.f90:1340:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.nx and MEM[(struct field_type *)&self].internal.ny
gnu_opt_report.txt:field_mod.f90:1340:0: note: Detected interleaving store MEM[(struct field_type *)&self].whole.nx and MEM[(struct field_type *)&self].whole.ny
gnu_opt_report.txt:field_mod.f90:1340:0: note: Detected interleaving store MEM[(struct field_type *)&self].whole.nx and MEM[(struct field_type *)&self].whole.xstart
gnu_opt_report.txt:field_mod.f90:1340:0: note: Detected interleaving store MEM[(struct field_type *)&self].whole.nx and MEM[(struct field_type *)&self].whole.xstop
gnu_opt_report.txt:field_mod.f90:1340:0: note: Detected interleaving store MEM[(struct field_type *)&self].whole.nx and MEM[(struct field_type *)&self].whole.ystart
gnu_opt_report.txt:field_mod.f90:1340:0: note: Detected interleaving store MEM[(struct field_type *)&self].whole.nx and MEM[(struct field_type *)&self].whole.ystop
gnu_opt_report.txt:field_mod.f90:1340:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].internal.nx = _332;
gnu_opt_report.txt:field_mod.f90:1340:0: note: Detected interleaving store of size 6 starting with MEM[(struct field_type *)&self].whole.nx = _352;
gnu_opt_report.txt:field_mod.f90:1340:0: note: Build SLP for MEM[(struct field_type *)&self].internal.nx = _332;
gnu_opt_report.txt:field_mod.f90:1340:0: note: Build SLP for MEM[(struct field_type *)&self].whole.nx = _352;
gnu_opt_report.txt:field_mod.f90:1340:0: note: Build SLP for MEM[(struct field_type *)&self].whole.ny = _356;
gnu_opt_report.txt:field_mod.f90:1340:0: note: Build SLP for MEM[(struct field_type *)&self].whole.xstart = prephitmp_1593;
gnu_opt_report.txt:field_mod.f90:1340:0: note: Build SLP for MEM[(struct field_type *)&self].whole.xstop = prephitmp_1609;
gnu_opt_report.txt:field_mod.f90:1340:0: note: Build SLP for MEM[(struct field_type *)&self].whole.ystart = prephitmp_1638;
gnu_opt_report.txt:field_mod.f90:1340:0: note: Build SLP for MEM[(struct field_type *)&self].whole.ystop = prephitmp_1655;
gnu_opt_report.txt:field_mod.f90:1340:0: note:   based on:     MEM[(struct field_type *)&self].internal.nx = _332;
gnu_opt_report.txt:field_mod.f90:1202:0: note: got vectype for stmt: pretmp_1728 = self.field_type.grid;
gnu_opt_report.txt:field_mod.f90:1202:0: note: not consecutive access pretmp_1728 = self.field_type.grid;
gnu_opt_report.txt: scalar_type: struct field_type
gnu_opt_report.txt:field_mod.f90:1362:0: note: not vectorized: no vectype for stmt: *dst_11(D).field_type = *src_12(D).field_type;
gnu_opt_report.txt: scalar_type: struct field_type
gnu_opt_report.txt:field_mod.f90:1362:0: note: not vectorized: more than one data ref in stmt: *dst_11(D).field_type = *src_12(D).field_type;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _2 = *src_12(D).field_type.halo.dim[0].ubound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _3 = *src_12(D).field_type.halo.dim[0].lbound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: Detected interleaving load *src_12(D).field_type.halo.dim[0].lbound and *src_12(D).field_type.halo.dim[0].ubound
gnu_opt_report.txt:field_mod.f90:1362:0: note: Detected interleaving load of size 2 starting with _3 = *src_12(D).field_type.halo.dim[0].lbound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: *dst_11(D).field_type.halo.data = _18;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: *dst_11(D).field_type.halo.data = 0B;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _87 = MEM[(struct array15_field_type *)array_39(D)].dim[_84].ubound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _88 = MEM[(struct array15_field_type *)array_39(D)].dim[_84].lbound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: Detected interleaving load MEM[(struct array15_field_type *)array_39(D)].dim[_84].lbound and MEM[(struct array15_field_type *)array_39(D)].dim[_84].ubound
gnu_opt_report.txt:field_mod.f90:1362:0: note: Detected interleaving load of size 3 starting with _88 = MEM[(struct array15_field_type *)array_39(D)].dim[_84].lbound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: init: stmt relevant? _87 = MEM[(struct array15_field_type *)array_39(D)].dim[_84].ubound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: init: stmt relevant? _88 = MEM[(struct array15_field_type *)array_39(D)].dim[_84].lbound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: def_stmt: _87 = MEM[(struct array15_field_type *)array_39(D)].dim[_84].ubound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: mark relevant 5, live 0: _87 = MEM[(struct array15_field_type *)array_39(D)].dim[_84].ubound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: def_stmt: _88 = MEM[(struct array15_field_type *)array_39(D)].dim[_84].lbound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: mark relevant 5, live 0: _88 = MEM[(struct array15_field_type *)array_39(D)].dim[_84].lbound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: worklist: examine stmt: _88 = MEM[(struct array15_field_type *)array_39(D)].dim[_84].lbound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: worklist: examine stmt: _87 = MEM[(struct array15_field_type *)array_39(D)].dim[_84].ubound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _268 = MEM[(struct array15_field_type &)array_39(D)].dim[_269].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: Detected single element interleaving MEM[(struct array15_field_type &)array_39(D)].dim[_269].stride step 24
gnu_opt_report.txt:field_mod.f90:1362:0: note: init: stmt relevant? _268 = MEM[(struct array15_field_type &)array_39(D)].dim[_269].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: def_stmt: _268 = MEM[(struct array15_field_type &)array_39(D)].dim[_269].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: mark relevant 5, live 0: _268 = MEM[(struct array15_field_type &)array_39(D)].dim[_269].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: worklist: examine stmt: _268 = MEM[(struct array15_field_type &)array_39(D)].dim[_269].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: ==> examining statement: _268 = MEM[(struct array15_field_type &)array_39(D)].dim[_269].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note:   based on:     _268 = MEM[(struct array15_field_type &)array_39(D)].dim[_269].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: can't force alignment of ref: MEM[(struct array15_field_type &)array_39(D)].dim[_269].stride
gnu_opt_report.txt:field_mod.f90:1362:0: note: ==> examining statement: _268 = MEM[(struct array15_field_type &)array_39(D)].dim[_269].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: vect_is_simple_use: operand MEM[(struct array15_field_type &)array_39(D)].dim[_269].stride
gnu_opt_report.txt:field_mod.f90:1362:0: note: vect_is_simple_use: operand MEM[(struct array15_field_type &)array_39(D)].dim[_269].stride
gnu_opt_report.txt:field_mod.f90:1362:0: note: def_stmt: _268 = MEM[(struct array15_field_type &)array_39(D)].dim[_269].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: pretmp_256 = MEM[(struct array15_field_type &)array_39(D)].dtype.rank;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access pretmp_256 = MEM[(struct array15_field_type &)array_39(D)].dtype.rank;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _245 = MEM[(struct array15_field_type &)array_39(D)].dim[_207].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _245 = MEM[(struct array15_field_type &)array_39(D)].dim[_207].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _186 = MEM[(struct array15_field_type &)array_39(D)].dim[_187].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _186 = MEM[(struct array15_field_type &)array_39(D)].dim[_187].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _180 = MEM[(struct array15_field_type &)array_39(D)].dim[_181].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _180 = MEM[(struct array15_field_type &)array_39(D)].dim[_181].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _174 = MEM[(struct array15_field_type &)array_39(D)].dim[_175].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _174 = MEM[(struct array15_field_type &)array_39(D)].dim[_175].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _168 = MEM[(struct array15_field_type &)array_39(D)].dim[_169].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _168 = MEM[(struct array15_field_type &)array_39(D)].dim[_169].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _162 = MEM[(struct array15_field_type &)array_39(D)].dim[_163].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _162 = MEM[(struct array15_field_type &)array_39(D)].dim[_163].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _156 = MEM[(struct array15_field_type &)array_39(D)].dim[_157].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _156 = MEM[(struct array15_field_type &)array_39(D)].dim[_157].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _148 = MEM[(struct array15_field_type &)array_39(D)].dim[_149].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _148 = MEM[(struct array15_field_type &)array_39(D)].dim[_149].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _118 = MEM[(struct array15_field_type &)array_39(D)].dim[_136].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _118 = MEM[(struct array15_field_type &)array_39(D)].dim[_136].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _34 = MEM[(struct array15_field_type &)array_39(D)].dim[_83].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _34 = MEM[(struct array15_field_type &)array_39(D)].dim[_83].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _28 = MEM[(struct array15_field_type &)array_39(D)].dim[_29].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _28 = MEM[(struct array15_field_type &)array_39(D)].dim[_29].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _296 = MEM[(struct array15_field_type &)array_39(D)].dim[_297].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _296 = MEM[(struct array15_field_type &)array_39(D)].dim[_297].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _281 = MEM[(struct array15_field_type &)array_39(D)].dim[_283].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _281 = MEM[(struct array15_field_type &)array_39(D)].dim[_283].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _240 = MEM[(struct array15_field_type &)array_39(D)].dim[_246].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _240 = MEM[(struct array15_field_type &)array_39(D)].dim[_246].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _58 = MEM[(struct array15_field_type &)array_39(D)].dim[_15].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _58 = MEM[(struct array15_field_type &)array_39(D)].dim[_15].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _75 = MEM[(struct array15_field_type &)array_39(D)].dim[_74].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _75 = MEM[(struct array15_field_type &)array_39(D)].dim[_74].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _268 = MEM[(struct array15_field_type &)array_39(D)].dim[_269].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _268 = MEM[(struct array15_field_type &)array_39(D)].dim[_269].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _87 = MEM[(struct array15_field_type *)array_39(D)].dim[_84].ubound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _88 = MEM[(struct array15_field_type *)array_39(D)].dim[_84].lbound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: Detected interleaving load MEM[(struct array15_field_type *)array_39(D)].dim[_84].lbound and MEM[(struct array15_field_type *)array_39(D)].dim[_84].ubound
gnu_opt_report.txt:field_mod.f90:1362:0: note: Detected interleaving load of size 2 starting with _88 = MEM[(struct array15_field_type *)array_39(D)].dim[_84].lbound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _111 = MEM[(struct array15_field_type &)array_39(D)].data;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: pretmp_294 = MEM[(struct array15_field_type &)array_39(D)].dtype.rank;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: pretmp_257 = MEM[(struct array15_field_type &)array_39(D)].dtype.rank;
gnu_opt_report.txt:field_mod.f90:243:0: note: got vectype for stmt: self.field_type.halo.data = 0B;
gnu_opt_report.txt:field_mod.f90:243:0: note: got vectype for stmt: self.field_type.grid = grid_58(D);
gnu_opt_report.txt:field_mod.f90:243:0: note: got vectype for stmt: self.field_type.data_on_device = 0;
gnu_opt_report.txt:field_mod.f90:243:0: note: not consecutive access self.field_type.data_on_device = 0;
gnu_opt_report.txt:field_mod.f90:243:0: note: not consecutive access self.field_type.grid = grid_58(D);
gnu_opt_report.txt:field_mod.f90:243:0: note: not consecutive access self.field_type.halo.data = 0B;
gnu_opt_report.txt:field_mod.f90:317:0: note: got vectype for stmt: MEM[(struct field_type *)&self].defined_on = 0;
gnu_opt_report.txt:field_mod.f90:317:0: note: not consecutive access MEM[(struct field_type *)&self].defined_on = 0;
gnu_opt_report.txt:field_mod.f90:969:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstart = pretmp_1875;
gnu_opt_report.txt:field_mod.f90:969:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstop = pretmp_1876;
gnu_opt_report.txt:field_mod.f90:969:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystart = pretmp_1877;
gnu_opt_report.txt:field_mod.f90:969:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystop = pretmp_1878;
gnu_opt_report.txt:field_mod.f90:969:0: note: got vectype for stmt: MEM[(struct field_type *)&self].num_halos = 2;
gnu_opt_report.txt:field_mod.f90:969:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:969:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystart
gnu_opt_report.txt:field_mod.f90:969:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:969:0: note: Detected interleaving store of size 4 starting with MEM[(struct field_type *)&self].internal.xstart = pretmp_1875;
gnu_opt_report.txt:field_mod.f90:969:0: note: not consecutive access MEM[(struct field_type *)&self].num_halos = 2;
gnu_opt_report.txt:field_mod.f90:969:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstart = pretmp_1875;
gnu_opt_report.txt:field_mod.f90:969:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstop = pretmp_1876;
gnu_opt_report.txt:field_mod.f90:969:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystart = pretmp_1877;
gnu_opt_report.txt:field_mod.f90:969:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystop = pretmp_1878;
gnu_opt_report.txt:field_mod.f90:969:0: note: 	stmt 0 MEM[(struct field_type *)&self].internal.xstart = pretmp_1875;
gnu_opt_report.txt:field_mod.f90:969:0: note: 	stmt 1 MEM[(struct field_type *)&self].internal.xstop = pretmp_1876;
gnu_opt_report.txt:field_mod.f90:969:0: note: 	stmt 2 MEM[(struct field_type *)&self].internal.ystart = pretmp_1877;
gnu_opt_report.txt:field_mod.f90:969:0: note: 	stmt 3 MEM[(struct field_type *)&self].internal.ystop = pretmp_1878;
gnu_opt_report.txt:field_mod.f90:969:0: note:   based on:     MEM[(struct field_type *)&self].internal.xstart = pretmp_1875;
gnu_opt_report.txt:field_mod.f90:969:0: note: misalign = 8 bytes of ref MEM[(struct field_type *)&self].internal.xstart
gnu_opt_report.txt:field_mod.f90:969:0: note: ==> examining statement: MEM[(struct field_type *)&self].internal.xstart = pretmp_1875;
gnu_opt_report.txt:field_mod.f90:969:0: note: ------>vectorizing SLP node starting from: MEM[(struct field_type *)&self].internal.xstart = pretmp_1875;
gnu_opt_report.txt:field_mod.f90:969:0: note: create vector_type-pointer variable to type: vector(4) integer(kind=4)  vectorizing a pointer ref: MEM[(struct field_type *)&self].internal.xstart
gnu_opt_report.txt:field_mod.f90:969:0: note: created &MEM[(struct field_type *)&self].internal.xstart
gnu_opt_report.txt:field_mod.f90:967:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstart = _366;
gnu_opt_report.txt:field_mod.f90:967:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstop = pretmp_1876;
gnu_opt_report.txt:field_mod.f90:967:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystart = pretmp_1877;
gnu_opt_report.txt:field_mod.f90:967:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystop = pretmp_1878;
gnu_opt_report.txt:field_mod.f90:967:0: note: got vectype for stmt: MEM[(struct field_type *)&self].num_halos = 0;
gnu_opt_report.txt:field_mod.f90:967:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:967:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystart
gnu_opt_report.txt:field_mod.f90:967:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:967:0: note: Detected interleaving store of size 4 starting with MEM[(struct field_type *)&self].internal.xstart = _366;
gnu_opt_report.txt:field_mod.f90:967:0: note: not consecutive access MEM[(struct field_type *)&self].num_halos = 0;
gnu_opt_report.txt:field_mod.f90:967:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstart = _366;
gnu_opt_report.txt:field_mod.f90:967:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstop = pretmp_1876;
gnu_opt_report.txt:field_mod.f90:967:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystart = pretmp_1877;
gnu_opt_report.txt:field_mod.f90:967:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystop = pretmp_1878;
gnu_opt_report.txt:field_mod.f90:967:0: note:   based on:     MEM[(struct field_type *)&self].internal.xstart = _366;
gnu_opt_report.txt:field_mod.f90:972:0: note: got vectype for stmt: MEM[(struct field_type *)&self].num_halos = prephitmp_1880;
gnu_opt_report.txt:field_mod.f90:975:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dtype.elem_len = 52;
gnu_opt_report.txt:field_mod.f90:975:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dtype.rank = 1;
gnu_opt_report.txt:field_mod.f90:975:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dtype.type = 5;
gnu_opt_report.txt:field_mod.f90:975:0: note: Detected interleaving store MEM[(struct field_type *)&self].halo.dtype.rank and MEM[(struct field_type *)&self].halo.dtype.type
gnu_opt_report.txt:field_mod.f90:975:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].halo.dtype.rank = 1;
gnu_opt_report.txt:field_mod.f90:975:0: note: not consecutive access MEM[(struct field_type *)&self].halo.dtype.elem_len = 52;
gnu_opt_report.txt:field_mod.f90:975:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dtype.rank = 1;
gnu_opt_report.txt:field_mod.f90:975:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.data = _387;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dim[0].lbound = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dim[0].ubound = _392;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dim[0].stride = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.offset = -1;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving store MEM[(struct field_type *)&self].halo.span and MEM[(struct field_type *)&self].halo.dim[0].stride
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving store MEM[(struct field_type *)&self].halo.span and MEM[(struct field_type *)&self].halo.dim[0].lbound
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving store MEM[(struct field_type *)&self].halo.span and MEM[(struct field_type *)&self].halo.dim[0].ubound
gnu_opt_report.txt:field_mod.f90:978:0: note: not consecutive access MEM[(struct field_type *)&self].halo.offset = -1;
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving store of size 4 starting with MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dim[0].stride = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dim[0].lbound = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dim[0].ubound = _392;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP failed: different operation in stmt MEM[(struct field_type *)&self].halo.dim[0].ubound = _392;
gnu_opt_report.txt:field_mod.f90:978:0: note: original stmt MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dim[0].stride = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: 	stmt 0 MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: 	stmt 1 MEM[(struct field_type *)&self].halo.dim[0].stride = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note:   based on:     MEM[(struct field_type *)&self].halo.dim[0].lbound = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: misalign = 8 bytes of ref MEM[(struct field_type *)&self].halo.span
gnu_opt_report.txt:field_mod.f90:978:0: note: ==> examining statement: MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: ------>vectorizing SLP node starting from: MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: create vector_type-pointer variable to type: vector(2) integer(kind=8)  vectorizing a pointer ref: MEM[(struct field_type *)&self].halo.span
gnu_opt_report.txt:field_mod.f90:978:0: note: created &MEM[(struct field_type *)&self].halo.span
gnu_opt_report.txt:field_mod.f90:1004:0: note: got vectype for stmt: pretmp_1543 = MEM[(struct field_type *)&self].internal.ystop;
gnu_opt_report.txt:field_mod.f90:1004:0: note: got vectype for stmt: pretmp_1557 = MEM[(struct field_type *)&self].internal.ystart;
gnu_opt_report.txt:field_mod.f90:1004:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.ystart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:1004:0: note: Detected interleaving load of size 2 starting with pretmp_1557 = MEM[(struct field_type *)&self].internal.ystart;
gnu_opt_report.txt:field_mod.f90:1027:0: note: got vectype for stmt: pretmp_1544 = MEM[(struct field_type *)&self].internal.ystop;
gnu_opt_report.txt:field_mod.f90:1027:0: note: got vectype for stmt: pretmp_1558 = MEM[(struct field_type *)&self].internal.ystart;
gnu_opt_report.txt:field_mod.f90:1027:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.ystart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:1027:0: note: Detected interleaving load of size 2 starting with pretmp_1558 = MEM[(struct field_type *)&self].internal.ystart;
gnu_opt_report.txt:field_mod.f90:1027:0: note:   based on:     pretmp_1544 = MEM[(struct field_type *)&self].internal.ystop;
gnu_opt_report.txt:field_mod.f90:455:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstart = _417;
gnu_opt_report.txt:field_mod.f90:455:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstop = _419;
gnu_opt_report.txt:field_mod.f90:455:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:455:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].internal.xstart = _417;
gnu_opt_report.txt:field_mod.f90:455:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstart = _417;
gnu_opt_report.txt:field_mod.f90:455:0: note:   based on:     MEM[(struct field_type *)&self].internal.xstart = _417;
gnu_opt_report.txt:field_mod.f90:461:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystart = _423;
gnu_opt_report.txt:field_mod.f90:461:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystop = _424;
gnu_opt_report.txt:field_mod.f90:461:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.ystart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:461:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].internal.ystart = _423;
gnu_opt_report.txt:field_mod.f90:461:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystart = _423;
gnu_opt_report.txt:field_mod.f90:461:0: note:   based on:     MEM[(struct field_type *)&self].internal.ystart = _423;
gnu_opt_report.txt:field_mod.f90:463:0: note: got vectype for stmt: pretmp_1868 = MEM[(struct field_type *)&self].internal.ystop;
gnu_opt_report.txt:field_mod.f90:463:0: note: got vectype for stmt: pretmp_1870 = MEM[(struct field_type *)&self].internal.ystart;
gnu_opt_report.txt:field_mod.f90:463:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.ystart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:463:0: note: Detected interleaving load of size 2 starting with pretmp_1870 = MEM[(struct field_type *)&self].internal.ystart;
gnu_opt_report.txt:field_mod.f90:467:0: note: got vectype for stmt: MEM[(struct field_type *)&self].num_halos = 0;
gnu_opt_report.txt:field_mod.f90:467:0: note: got vectype for stmt: pretmp_1506 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:467:0: note: got vectype for stmt: pretmp_1520 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:467:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:467:0: note: Detected interleaving load of size 2 starting with pretmp_1520 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:467:0: note: not consecutive access MEM[(struct field_type *)&self].num_halos = 0;
gnu_opt_report.txt:field_mod.f90:317:0: note: got vectype for stmt: pretmp_1517 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:317:0: note: got vectype for stmt: pretmp_1531 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:317:0: note: got vectype for stmt: pretmp_1545 = MEM[(struct field_type *)&self].internal.ystop;
gnu_opt_report.txt:field_mod.f90:317:0: note: got vectype for stmt: pretmp_1559 = MEM[(struct field_type *)&self].internal.ystart;
gnu_opt_report.txt:field_mod.f90:317:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:317:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystart
gnu_opt_report.txt:field_mod.f90:317:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:317:0: note: Detected interleaving load of size 4 starting with pretmp_1531 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:488:0: note: got vectype for stmt: MEM[(struct field_type *)&self].defined_on = 1;
gnu_opt_report.txt:field_mod.f90:488:0: note: not consecutive access MEM[(struct field_type *)&self].defined_on = 1;
gnu_opt_report.txt:field_mod.f90:509:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstart = pretmp_1826;
gnu_opt_report.txt:field_mod.f90:509:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstop = pretmp_1827;
gnu_opt_report.txt:field_mod.f90:509:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystart = pretmp_1824;
gnu_opt_report.txt:field_mod.f90:509:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystop = pretmp_1825;
gnu_opt_report.txt:field_mod.f90:509:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:509:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystart
gnu_opt_report.txt:field_mod.f90:509:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:509:0: note: Detected interleaving store of size 4 starting with MEM[(struct field_type *)&self].internal.xstart = pretmp_1826;
gnu_opt_report.txt:field_mod.f90:509:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstart = pretmp_1826;
gnu_opt_report.txt:field_mod.f90:509:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstop = pretmp_1827;
gnu_opt_report.txt:field_mod.f90:509:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystart = pretmp_1824;
gnu_opt_report.txt:field_mod.f90:509:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystop = pretmp_1825;
gnu_opt_report.txt:field_mod.f90:509:0: note: 	stmt 0 MEM[(struct field_type *)&self].internal.xstart = pretmp_1826;
gnu_opt_report.txt:field_mod.f90:509:0: note: 	stmt 1 MEM[(struct field_type *)&self].internal.xstop = pretmp_1827;
gnu_opt_report.txt:field_mod.f90:509:0: note: 	stmt 2 MEM[(struct field_type *)&self].internal.ystart = pretmp_1824;
gnu_opt_report.txt:field_mod.f90:509:0: note: 	stmt 3 MEM[(struct field_type *)&self].internal.ystop = pretmp_1825;
gnu_opt_report.txt:field_mod.f90:509:0: note:   based on:     MEM[(struct field_type *)&self].internal.xstart = pretmp_1826;
gnu_opt_report.txt:field_mod.f90:509:0: note: misalign = 8 bytes of ref MEM[(struct field_type *)&self].internal.xstart
gnu_opt_report.txt:field_mod.f90:509:0: note: ==> examining statement: MEM[(struct field_type *)&self].internal.xstart = pretmp_1826;
gnu_opt_report.txt:field_mod.f90:509:0: note: ------>vectorizing SLP node starting from: MEM[(struct field_type *)&self].internal.xstart = pretmp_1826;
gnu_opt_report.txt:field_mod.f90:509:0: note: create vector_type-pointer variable to type: vector(4) integer(kind=4)  vectorizing a pointer ref: MEM[(struct field_type *)&self].internal.xstart
gnu_opt_report.txt:field_mod.f90:509:0: note: created &MEM[(struct field_type *)&self].internal.xstart
gnu_opt_report.txt:field_mod.f90:527:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstart = pretmp_1826;
gnu_opt_report.txt:field_mod.f90:527:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstop = pretmp_1827;
gnu_opt_report.txt:field_mod.f90:527:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystart = _439;
gnu_opt_report.txt:field_mod.f90:527:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystop = pretmp_1825;
gnu_opt_report.txt:field_mod.f90:527:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:527:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystart
gnu_opt_report.txt:field_mod.f90:527:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:527:0: note: Detected interleaving store of size 4 starting with MEM[(struct field_type *)&self].internal.xstart = pretmp_1826;
gnu_opt_report.txt:field_mod.f90:527:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstart = pretmp_1826;
gnu_opt_report.txt:field_mod.f90:527:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstop = pretmp_1827;
gnu_opt_report.txt:field_mod.f90:527:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystart = _439;
gnu_opt_report.txt:field_mod.f90:527:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystop = pretmp_1825;
gnu_opt_report.txt:field_mod.f90:527:0: note:   based on:     MEM[(struct field_type *)&self].internal.xstart = pretmp_1826;
gnu_opt_report.txt:field_mod.f90:968:0: note: got vectype for stmt: MEM[(struct field_type *)&self].num_halos = 0;
gnu_opt_report.txt:field_mod.f90:968:0: note: not consecutive access MEM[(struct field_type *)&self].num_halos = 0;
gnu_opt_report.txt:field_mod.f90:969:0: note: got vectype for stmt: MEM[(struct field_type *)&self].num_halos = 2;
gnu_opt_report.txt:field_mod.f90:972:0: note: got vectype for stmt: MEM[(struct field_type *)&self].num_halos = prephitmp_1835;
gnu_opt_report.txt:field_mod.f90:975:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dtype.elem_len = 52;
gnu_opt_report.txt:field_mod.f90:975:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dtype.rank = 1;
gnu_opt_report.txt:field_mod.f90:975:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dtype.type = 5;
gnu_opt_report.txt:field_mod.f90:975:0: note: Detected interleaving store MEM[(struct field_type *)&self].halo.dtype.rank and MEM[(struct field_type *)&self].halo.dtype.type
gnu_opt_report.txt:field_mod.f90:975:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].halo.dtype.rank = 1;
gnu_opt_report.txt:field_mod.f90:975:0: note: not consecutive access MEM[(struct field_type *)&self].halo.dtype.elem_len = 52;
gnu_opt_report.txt:field_mod.f90:975:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dtype.rank = 1;
gnu_opt_report.txt:field_mod.f90:975:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.data = _458;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dim[0].lbound = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dim[0].ubound = _463;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dim[0].stride = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.offset = -1;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving store MEM[(struct field_type *)&self].halo.span and MEM[(struct field_type *)&self].halo.dim[0].stride
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving store MEM[(struct field_type *)&self].halo.span and MEM[(struct field_type *)&self].halo.dim[0].lbound
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving store MEM[(struct field_type *)&self].halo.span and MEM[(struct field_type *)&self].halo.dim[0].ubound
gnu_opt_report.txt:field_mod.f90:978:0: note: not consecutive access MEM[(struct field_type *)&self].halo.offset = -1;
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving store of size 4 starting with MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dim[0].stride = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dim[0].lbound = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dim[0].ubound = _463;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP failed: different operation in stmt MEM[(struct field_type *)&self].halo.dim[0].ubound = _463;
gnu_opt_report.txt:field_mod.f90:978:0: note: original stmt MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dim[0].stride = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: 	stmt 0 MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: 	stmt 1 MEM[(struct field_type *)&self].halo.dim[0].stride = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note:   based on:     MEM[(struct field_type *)&self].halo.dim[0].lbound = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: misalign = 8 bytes of ref MEM[(struct field_type *)&self].halo.span
gnu_opt_report.txt:field_mod.f90:978:0: note: ==> examining statement: MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: ------>vectorizing SLP node starting from: MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: create vector_type-pointer variable to type: vector(2) integer(kind=8)  vectorizing a pointer ref: MEM[(struct field_type *)&self].halo.span
gnu_opt_report.txt:field_mod.f90:978:0: note: created &MEM[(struct field_type *)&self].halo.span
gnu_opt_report.txt:field_mod.f90:589:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstart = _488;
gnu_opt_report.txt:field_mod.f90:589:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstop = _489;
gnu_opt_report.txt:field_mod.f90:589:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:589:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].internal.xstart = _488;
gnu_opt_report.txt:field_mod.f90:589:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstart = _488;
gnu_opt_report.txt:field_mod.f90:589:0: note:   based on:     MEM[(struct field_type *)&self].internal.xstart = _488;
gnu_opt_report.txt:field_mod.f90:596:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystart = _493;
gnu_opt_report.txt:field_mod.f90:596:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystop = _495;
gnu_opt_report.txt:field_mod.f90:596:0: note: got vectype for stmt: pretmp_1515 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:596:0: note: got vectype for stmt: pretmp_1529 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:596:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:596:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.ystart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:596:0: note: Detected interleaving load of size 2 starting with pretmp_1529 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:596:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].internal.ystart = _493;
gnu_opt_report.txt:field_mod.f90:596:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystart = _493;
gnu_opt_report.txt:field_mod.f90:596:0: note:   based on:     MEM[(struct field_type *)&self].internal.ystart = _493;
gnu_opt_report.txt:field_mod.f90:598:0: note: got vectype for stmt: pretmp_1507 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:598:0: note: got vectype for stmt: pretmp_1521 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:598:0: note: got vectype for stmt: pretmp_1535 = MEM[(struct field_type *)&self].internal.ystop;
gnu_opt_report.txt:field_mod.f90:598:0: note: got vectype for stmt: pretmp_1549 = MEM[(struct field_type *)&self].internal.ystart;
gnu_opt_report.txt:field_mod.f90:598:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:598:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystart
gnu_opt_report.txt:field_mod.f90:598:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:598:0: note: Detected interleaving load of size 4 starting with pretmp_1521 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:488:0: note: got vectype for stmt: pretmp_1514 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:488:0: note: got vectype for stmt: pretmp_1528 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:488:0: note: got vectype for stmt: pretmp_1542 = MEM[(struct field_type *)&self].internal.ystop;
gnu_opt_report.txt:field_mod.f90:488:0: note: got vectype for stmt: pretmp_1556 = MEM[(struct field_type *)&self].internal.ystart;
gnu_opt_report.txt:field_mod.f90:488:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:488:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystart
gnu_opt_report.txt:field_mod.f90:488:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:488:0: note: Detected interleaving load of size 4 starting with pretmp_1528 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:620:0: note: got vectype for stmt: MEM[(struct field_type *)&self].defined_on = 2;
gnu_opt_report.txt:field_mod.f90:620:0: note: not consecutive access MEM[(struct field_type *)&self].defined_on = 2;
gnu_opt_report.txt:field_mod.f90:968:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstart = _501;
gnu_opt_report.txt:field_mod.f90:968:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstop = _502;
gnu_opt_report.txt:field_mod.f90:968:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystart = _503;
gnu_opt_report.txt:field_mod.f90:968:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystop = _504;
gnu_opt_report.txt:field_mod.f90:968:0: note: got vectype for stmt: MEM[(struct field_type *)&self].num_halos = 0;
gnu_opt_report.txt:field_mod.f90:968:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:968:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystart
gnu_opt_report.txt:field_mod.f90:968:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:968:0: note: Detected interleaving store of size 4 starting with MEM[(struct field_type *)&self].internal.xstart = _501;
gnu_opt_report.txt:field_mod.f90:968:0: note: not consecutive access MEM[(struct field_type *)&self].num_halos = 0;
gnu_opt_report.txt:field_mod.f90:968:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstart = _501;
gnu_opt_report.txt:field_mod.f90:968:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstop = _502;
gnu_opt_report.txt:field_mod.f90:968:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystart = _503;
gnu_opt_report.txt:field_mod.f90:968:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystop = _504;
gnu_opt_report.txt:field_mod.f90:968:0: note: 	stmt 0 MEM[(struct field_type *)&self].internal.xstart = _501;
gnu_opt_report.txt:field_mod.f90:968:0: note: 	stmt 1 MEM[(struct field_type *)&self].internal.xstop = _502;
gnu_opt_report.txt:field_mod.f90:968:0: note: 	stmt 2 MEM[(struct field_type *)&self].internal.ystart = _503;
gnu_opt_report.txt:field_mod.f90:968:0: note: 	stmt 3 MEM[(struct field_type *)&self].internal.ystop = _504;
gnu_opt_report.txt:field_mod.f90:968:0: note:   based on:     MEM[(struct field_type *)&self].internal.xstart = _501;
gnu_opt_report.txt:field_mod.f90:968:0: note: misalign = 8 bytes of ref MEM[(struct field_type *)&self].internal.xstart
gnu_opt_report.txt:field_mod.f90:968:0: note: ==> examining statement: MEM[(struct field_type *)&self].internal.xstart = _501;
gnu_opt_report.txt:field_mod.f90:968:0: note: ------>vectorizing SLP node starting from: MEM[(struct field_type *)&self].internal.xstart = _501;
gnu_opt_report.txt:field_mod.f90:968:0: note: create vector_type-pointer variable to type: vector(4) integer(kind=4)  vectorizing a pointer ref: MEM[(struct field_type *)&self].internal.xstart
gnu_opt_report.txt:field_mod.f90:968:0: note: created &MEM[(struct field_type *)&self].internal.xstart
gnu_opt_report.txt:field_mod.f90:969:0: note: got vectype for stmt: MEM[(struct field_type *)&self].num_halos = 2;
gnu_opt_report.txt:field_mod.f90:972:0: note: got vectype for stmt: MEM[(struct field_type *)&self].num_halos = prephitmp_1796;
gnu_opt_report.txt:field_mod.f90:975:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dtype.elem_len = 52;
gnu_opt_report.txt:field_mod.f90:975:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dtype.rank = 1;
gnu_opt_report.txt:field_mod.f90:975:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dtype.type = 5;
gnu_opt_report.txt:field_mod.f90:975:0: note: Detected interleaving store MEM[(struct field_type *)&self].halo.dtype.rank and MEM[(struct field_type *)&self].halo.dtype.type
gnu_opt_report.txt:field_mod.f90:975:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].halo.dtype.rank = 1;
gnu_opt_report.txt:field_mod.f90:975:0: note: not consecutive access MEM[(struct field_type *)&self].halo.dtype.elem_len = 52;
gnu_opt_report.txt:field_mod.f90:975:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dtype.rank = 1;
gnu_opt_report.txt:field_mod.f90:975:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.data = _522;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dim[0].lbound = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dim[0].ubound = _527;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dim[0].stride = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.offset = -1;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving store MEM[(struct field_type *)&self].halo.span and MEM[(struct field_type *)&self].halo.dim[0].stride
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving store MEM[(struct field_type *)&self].halo.span and MEM[(struct field_type *)&self].halo.dim[0].lbound
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving store MEM[(struct field_type *)&self].halo.span and MEM[(struct field_type *)&self].halo.dim[0].ubound
gnu_opt_report.txt:field_mod.f90:978:0: note: not consecutive access MEM[(struct field_type *)&self].halo.offset = -1;
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving store of size 4 starting with MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dim[0].stride = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dim[0].lbound = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dim[0].ubound = _527;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP failed: different operation in stmt MEM[(struct field_type *)&self].halo.dim[0].ubound = _527;
gnu_opt_report.txt:field_mod.f90:978:0: note: original stmt MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dim[0].stride = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: 	stmt 0 MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: 	stmt 1 MEM[(struct field_type *)&self].halo.dim[0].stride = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note:   based on:     MEM[(struct field_type *)&self].halo.dim[0].lbound = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: misalign = 8 bytes of ref MEM[(struct field_type *)&self].halo.span
gnu_opt_report.txt:field_mod.f90:978:0: note: ==> examining statement: MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: ------>vectorizing SLP node starting from: MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: create vector_type-pointer variable to type: vector(2) integer(kind=8)  vectorizing a pointer ref: MEM[(struct field_type *)&self].halo.span
gnu_opt_report.txt:field_mod.f90:978:0: note: created &MEM[(struct field_type *)&self].halo.span
gnu_opt_report.txt:field_mod.f90:692:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstart = _552;
gnu_opt_report.txt:field_mod.f90:692:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstop = _553;
gnu_opt_report.txt:field_mod.f90:692:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:692:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].internal.xstart = _552;
gnu_opt_report.txt:field_mod.f90:692:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstart = _552;
gnu_opt_report.txt:field_mod.f90:692:0: note:   based on:     MEM[(struct field_type *)&self].internal.xstart = _552;
gnu_opt_report.txt:field_mod.f90:701:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystart = _557;
gnu_opt_report.txt:field_mod.f90:701:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystop = _558;
gnu_opt_report.txt:field_mod.f90:701:0: note: got vectype for stmt: pretmp_1512 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:701:0: note: got vectype for stmt: pretmp_1526 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:701:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:701:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.ystart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:701:0: note: Detected interleaving load of size 2 starting with pretmp_1526 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:701:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].internal.ystart = _557;
gnu_opt_report.txt:field_mod.f90:701:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystart = _557;
gnu_opt_report.txt:field_mod.f90:701:0: note:   based on:     MEM[(struct field_type *)&self].internal.ystart = _557;
gnu_opt_report.txt:field_mod.f90:703:0: note: got vectype for stmt: pretmp_1508 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:703:0: note: got vectype for stmt: pretmp_1522 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:703:0: note: got vectype for stmt: pretmp_1536 = MEM[(struct field_type *)&self].internal.ystop;
gnu_opt_report.txt:field_mod.f90:703:0: note: got vectype for stmt: pretmp_1550 = MEM[(struct field_type *)&self].internal.ystart;
gnu_opt_report.txt:field_mod.f90:703:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:703:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystart
gnu_opt_report.txt:field_mod.f90:703:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:703:0: note: Detected interleaving load of size 4 starting with pretmp_1522 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:620:0: note: got vectype for stmt: pretmp_1511 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:620:0: note: got vectype for stmt: pretmp_1525 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:620:0: note: got vectype for stmt: pretmp_1540 = MEM[(struct field_type *)&self].internal.ystop;
gnu_opt_report.txt:field_mod.f90:620:0: note: got vectype for stmt: pretmp_1554 = MEM[(struct field_type *)&self].internal.ystart;
gnu_opt_report.txt:field_mod.f90:620:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:620:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystart
gnu_opt_report.txt:field_mod.f90:620:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:620:0: note: Detected interleaving load of size 4 starting with pretmp_1525 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:725:0: note: got vectype for stmt: MEM[(struct field_type *)&self].defined_on = 3;
gnu_opt_report.txt:field_mod.f90:725:0: note: not consecutive access MEM[(struct field_type *)&self].defined_on = 3;
gnu_opt_report.txt:field_mod.f90:748:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstart = pretmp_1745;
gnu_opt_report.txt:field_mod.f90:748:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstop = _568;
gnu_opt_report.txt:field_mod.f90:748:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:748:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].internal.xstart = pretmp_1745;
gnu_opt_report.txt:field_mod.f90:748:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstart = pretmp_1745;
gnu_opt_report.txt:field_mod.f90:748:0: note:   based on:     MEM[(struct field_type *)&self].internal.xstart = pretmp_1745;
gnu_opt_report.txt:field_mod.f90:754:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstart = _570;
gnu_opt_report.txt:field_mod.f90:754:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstop = _571;
gnu_opt_report.txt:field_mod.f90:754:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:754:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].internal.xstart = _570;
gnu_opt_report.txt:field_mod.f90:754:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstart = _570;
gnu_opt_report.txt:field_mod.f90:754:0: note:   based on:     MEM[(struct field_type *)&self].internal.xstart = _570;
gnu_opt_report.txt:field_mod.f90:759:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystart = pretmp_1759;
gnu_opt_report.txt:field_mod.f90:759:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystop = _578;
gnu_opt_report.txt:field_mod.f90:759:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.ystart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:759:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].internal.ystart = pretmp_1759;
gnu_opt_report.txt:field_mod.f90:759:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystart = pretmp_1759;
gnu_opt_report.txt:field_mod.f90:759:0: note:   based on:     MEM[(struct field_type *)&self].internal.ystart = pretmp_1759;
gnu_opt_report.txt:field_mod.f90:765:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystart = _580;
gnu_opt_report.txt:field_mod.f90:765:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystop = _581;
gnu_opt_report.txt:field_mod.f90:765:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.ystart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:765:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].internal.ystart = _580;
gnu_opt_report.txt:field_mod.f90:765:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystart = _580;
gnu_opt_report.txt:field_mod.f90:765:0: note:   based on:     MEM[(struct field_type *)&self].internal.ystart = _580;
gnu_opt_report.txt:field_mod.f90:968:0: note: got vectype for stmt: MEM[(struct field_type *)&self].num_halos = 0;
gnu_opt_report.txt:field_mod.f90:968:0: note: not consecutive access MEM[(struct field_type *)&self].num_halos = 0;
gnu_opt_report.txt:field_mod.f90:969:0: note: got vectype for stmt: MEM[(struct field_type *)&self].num_halos = 2;
gnu_opt_report.txt:field_mod.f90:972:0: note: got vectype for stmt: MEM[(struct field_type *)&self].num_halos = prephitmp_1767;
gnu_opt_report.txt:field_mod.f90:975:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dtype.elem_len = 52;
gnu_opt_report.txt:field_mod.f90:975:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dtype.rank = 1;
gnu_opt_report.txt:field_mod.f90:975:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dtype.type = 5;
gnu_opt_report.txt:field_mod.f90:975:0: note: Detected interleaving store MEM[(struct field_type *)&self].halo.dtype.rank and MEM[(struct field_type *)&self].halo.dtype.type
gnu_opt_report.txt:field_mod.f90:975:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].halo.dtype.rank = 1;
gnu_opt_report.txt:field_mod.f90:975:0: note: not consecutive access MEM[(struct field_type *)&self].halo.dtype.elem_len = 52;
gnu_opt_report.txt:field_mod.f90:975:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dtype.rank = 1;
gnu_opt_report.txt:field_mod.f90:975:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.data = _599;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dim[0].lbound = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dim[0].ubound = _604;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dim[0].stride = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.offset = -1;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: pretmp_1778 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: pretmp_1780 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving store MEM[(struct field_type *)&self].halo.span and MEM[(struct field_type *)&self].halo.dim[0].stride
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving store MEM[(struct field_type *)&self].halo.span and MEM[(struct field_type *)&self].halo.dim[0].lbound
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving store MEM[(struct field_type *)&self].halo.span and MEM[(struct field_type *)&self].halo.dim[0].ubound
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving load of size 2 starting with pretmp_1780 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:978:0: note: not consecutive access MEM[(struct field_type *)&self].halo.offset = -1;
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving store of size 4 starting with MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dim[0].stride = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dim[0].lbound = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dim[0].ubound = _604;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP failed: different operation in stmt MEM[(struct field_type *)&self].halo.dim[0].ubound = _604;
gnu_opt_report.txt:field_mod.f90:978:0: note: original stmt MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dim[0].stride = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: 	stmt 0 MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: 	stmt 1 MEM[(struct field_type *)&self].halo.dim[0].stride = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note:   based on:     MEM[(struct field_type *)&self].halo.dim[0].lbound = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: misalign = 8 bytes of ref MEM[(struct field_type *)&self].halo.span
gnu_opt_report.txt:field_mod.f90:978:0: note: ==> examining statement: MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: ------>vectorizing SLP node starting from: MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: create vector_type-pointer variable to type: vector(2) integer(kind=8)  vectorizing a pointer ref: MEM[(struct field_type *)&self].halo.span
gnu_opt_report.txt:field_mod.f90:978:0: note: created &MEM[(struct field_type *)&self].halo.span
gnu_opt_report.txt:field_mod.f90:1001:0: note: def_stmt: pretmp_1780 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:1001:0: note: def_stmt: pretmp_1780 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:1001:0: note: def_stmt: pretmp_1778 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:1001:0: note: def_stmt: pretmp_1778 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:1001:0: note: def_stmt: pretmp_1780 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:1001:0: note: def_stmt: pretmp_1780 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:1001:0: note: def_stmt: pretmp_1778 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:1001:0: note: def_stmt: pretmp_1778 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:1001:0: note: def_stmt: pretmp_1780 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:1001:0: note: def_stmt: pretmp_1778 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:1001:0: note: def_stmt: pretmp_1780 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:1001:0: note: def_stmt: pretmp_1780 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:1001:0: note: def_stmt: pretmp_1778 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:1001:0: note: def_stmt: pretmp_1778 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:821:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstart = _629;
gnu_opt_report.txt:field_mod.f90:821:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstop = _631;
gnu_opt_report.txt:field_mod.f90:821:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:821:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].internal.xstart = _629;
gnu_opt_report.txt:field_mod.f90:821:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstart = _629;
gnu_opt_report.txt:field_mod.f90:821:0: note:   based on:     MEM[(struct field_type *)&self].internal.xstart = _629;
gnu_opt_report.txt:field_mod.f90:823:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystart = _633;
gnu_opt_report.txt:field_mod.f90:823:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystop = _635;
gnu_opt_report.txt:field_mod.f90:823:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.ystart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:823:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].internal.ystart = _633;
gnu_opt_report.txt:field_mod.f90:823:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystart = _633;
gnu_opt_report.txt:field_mod.f90:823:0: note:   based on:     MEM[(struct field_type *)&self].internal.ystart = _633;
gnu_opt_report.txt:field_mod.f90:825:0: note: got vectype for stmt: pretmp_1537 = MEM[(struct field_type *)&self].internal.ystop;
gnu_opt_report.txt:field_mod.f90:825:0: note: got vectype for stmt: pretmp_1551 = MEM[(struct field_type *)&self].internal.ystart;
gnu_opt_report.txt:field_mod.f90:825:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.ystart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:825:0: note: Detected interleaving load of size 2 starting with pretmp_1551 = MEM[(struct field_type *)&self].internal.ystart;
gnu_opt_report.txt:field_mod.f90:725:0: note: got vectype for stmt: pretmp_1510 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:725:0: note: got vectype for stmt: pretmp_1524 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:725:0: note: got vectype for stmt: pretmp_1539 = MEM[(struct field_type *)&self].internal.ystop;
gnu_opt_report.txt:field_mod.f90:725:0: note: got vectype for stmt: pretmp_1553 = MEM[(struct field_type *)&self].internal.ystart;
gnu_opt_report.txt:field_mod.f90:725:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:725:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystart
gnu_opt_report.txt:field_mod.f90:725:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:725:0: note: Detected interleaving load of size 4 starting with pretmp_1524 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:296:0: note: got vectype for stmt: MEM[(struct field_type *)&self].defined_on = 4;
gnu_opt_report.txt:field_mod.f90:296:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstart = 1;
gnu_opt_report.txt:field_mod.f90:296:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstop = m_326;
gnu_opt_report.txt:field_mod.f90:296:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystart = 1;
gnu_opt_report.txt:field_mod.f90:296:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystop = n_327;
gnu_opt_report.txt:field_mod.f90:296:0: note: got vectype for stmt: MEM[(struct field_type *)&self].num_halos = 0;
gnu_opt_report.txt:field_mod.f90:296:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:296:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystart
gnu_opt_report.txt:field_mod.f90:296:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:296:0: note: not consecutive access MEM[(struct field_type *)&self].defined_on = 4;
gnu_opt_report.txt:field_mod.f90:296:0: note: Detected interleaving store of size 4 starting with MEM[(struct field_type *)&self].internal.xstart = 1;
gnu_opt_report.txt:field_mod.f90:296:0: note: not consecutive access MEM[(struct field_type *)&self].num_halos = 0;
gnu_opt_report.txt:field_mod.f90:296:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstart = 1;
gnu_opt_report.txt:field_mod.f90:296:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstop = m_326;
gnu_opt_report.txt:field_mod.f90:296:0: note: Build SLP failed: different operation in stmt MEM[(struct field_type *)&self].internal.xstop = m_326;
gnu_opt_report.txt:field_mod.f90:296:0: note: original stmt MEM[(struct field_type *)&self].internal.xstart = 1;
gnu_opt_report.txt:field_mod.f90:296:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystart = 1;
gnu_opt_report.txt:field_mod.f90:296:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystop = n_327;
gnu_opt_report.txt:field_mod.f90:296:0: note: Build SLP failed: different operation in stmt MEM[(struct field_type *)&self].internal.ystop = n_327;
gnu_opt_report.txt:field_mod.f90:296:0: note: original stmt MEM[(struct field_type *)&self].internal.xstart = 1;
gnu_opt_report.txt:field_mod.f90:296:0: note:   based on:     MEM[(struct field_type *)&self].defined_on = 4;
gnu_opt_report.txt:field_mod.f90:243:0: note: got vectype for stmt: pretmp_1509 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:243:0: note: got vectype for stmt: pretmp_1523 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:243:0: note: got vectype for stmt: pretmp_1538 = MEM[(struct field_type *)&self].internal.ystop;
gnu_opt_report.txt:field_mod.f90:243:0: note: got vectype for stmt: pretmp_1552 = MEM[(struct field_type *)&self].internal.ystart;
gnu_opt_report.txt:field_mod.f90:243:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:243:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystart
gnu_opt_report.txt:field_mod.f90:243:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:243:0: note: Detected interleaving load of size 4 starting with pretmp_1523 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:1340:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.nx = _332;
gnu_opt_report.txt:field_mod.f90:1340:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ny = _336;
gnu_opt_report.txt:field_mod.f90:1340:0: note: got vectype for stmt: MEM[(struct field_type *)&self].whole.xstop = prephitmp_1609;
gnu_opt_report.txt:field_mod.f90:1340:0: note: got vectype for stmt: MEM[(struct field_type *)&self].whole.xstart = prephitmp_1593;
gnu_opt_report.txt:field_mod.f90:1340:0: note: got vectype for stmt: MEM[(struct field_type *)&self].whole.ystop = prephitmp_1655;
gnu_opt_report.txt:field_mod.f90:1340:0: note: got vectype for stmt: MEM[(struct field_type *)&self].whole.ystart = prephitmp_1638;
gnu_opt_report.txt:field_mod.f90:1340:0: note: got vectype for stmt: MEM[(struct field_type *)&self].whole.nx = _352;
gnu_opt_report.txt:field_mod.f90:1340:0: note: got vectype for stmt: MEM[(struct field_type *)&self].whole.ny = _356;
gnu_opt_report.txt:field_mod.f90:1340:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.nx and MEM[(struct field_type *)&self].internal.ny
gnu_opt_report.txt:field_mod.f90:1340:0: note: Detected interleaving store MEM[(struct field_type *)&self].whole.nx and MEM[(struct field_type *)&self].whole.ny
gnu_opt_report.txt:field_mod.f90:1340:0: note: Detected interleaving store MEM[(struct field_type *)&self].whole.nx and MEM[(struct field_type *)&self].whole.xstart
gnu_opt_report.txt:field_mod.f90:1340:0: note: Detected interleaving store MEM[(struct field_type *)&self].whole.nx and MEM[(struct field_type *)&self].whole.xstop
gnu_opt_report.txt:field_mod.f90:1340:0: note: Detected interleaving store MEM[(struct field_type *)&self].whole.nx and MEM[(struct field_type *)&self].whole.ystart
gnu_opt_report.txt:field_mod.f90:1340:0: note: Detected interleaving store MEM[(struct field_type *)&self].whole.nx and MEM[(struct field_type *)&self].whole.ystop
gnu_opt_report.txt:field_mod.f90:1340:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].internal.nx = _332;
gnu_opt_report.txt:field_mod.f90:1340:0: note: Detected interleaving store of size 6 starting with MEM[(struct field_type *)&self].whole.nx = _352;
gnu_opt_report.txt:field_mod.f90:1340:0: note: Build SLP for MEM[(struct field_type *)&self].internal.nx = _332;
gnu_opt_report.txt:field_mod.f90:1340:0: note: Build SLP for MEM[(struct field_type *)&self].whole.nx = _352;
gnu_opt_report.txt:field_mod.f90:1340:0: note: Build SLP for MEM[(struct field_type *)&self].whole.ny = _356;
gnu_opt_report.txt:field_mod.f90:1340:0: note: Build SLP for MEM[(struct field_type *)&self].whole.xstart = prephitmp_1593;
gnu_opt_report.txt:field_mod.f90:1340:0: note: Build SLP for MEM[(struct field_type *)&self].whole.xstop = prephitmp_1609;
gnu_opt_report.txt:field_mod.f90:1340:0: note: Build SLP for MEM[(struct field_type *)&self].whole.ystart = prephitmp_1638;
gnu_opt_report.txt:field_mod.f90:1340:0: note: Build SLP for MEM[(struct field_type *)&self].whole.ystop = prephitmp_1655;
gnu_opt_report.txt:field_mod.f90:1340:0: note:   based on:     MEM[(struct field_type *)&self].internal.nx = _332;
gnu_opt_report.txt:field_mod.f90:1202:0: note: got vectype for stmt: pretmp_1728 = self.field_type.grid;
gnu_opt_report.txt:field_mod.f90:1202:0: note: not consecutive access pretmp_1728 = self.field_type.grid;
gnu_opt_report.txt: scalar_type: struct field_type
gnu_opt_report.txt:field_mod.f90:1362:0: note: not vectorized: no vectype for stmt: *dst_11(D).field_type = *src_12(D).field_type;
gnu_opt_report.txt: scalar_type: struct field_type
gnu_opt_report.txt:field_mod.f90:1362:0: note: not vectorized: more than one data ref in stmt: *dst_11(D).field_type = *src_12(D).field_type;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _2 = *src_12(D).field_type.halo.dim[0].ubound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _3 = *src_12(D).field_type.halo.dim[0].lbound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: Detected interleaving load *src_12(D).field_type.halo.dim[0].lbound and *src_12(D).field_type.halo.dim[0].ubound
gnu_opt_report.txt:field_mod.f90:1362:0: note: Detected interleaving load of size 2 starting with _3 = *src_12(D).field_type.halo.dim[0].lbound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: *dst_11(D).field_type.halo.data = _18;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: *dst_11(D).field_type.halo.data = 0B;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _87 = MEM[(struct array15_field_type *)array_39(D)].dim[_84].ubound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _88 = MEM[(struct array15_field_type *)array_39(D)].dim[_84].lbound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: Detected interleaving load MEM[(struct array15_field_type *)array_39(D)].dim[_84].lbound and MEM[(struct array15_field_type *)array_39(D)].dim[_84].ubound
gnu_opt_report.txt:field_mod.f90:1362:0: note: Detected interleaving load of size 3 starting with _88 = MEM[(struct array15_field_type *)array_39(D)].dim[_84].lbound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: init: stmt relevant? _87 = MEM[(struct array15_field_type *)array_39(D)].dim[_84].ubound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: init: stmt relevant? _88 = MEM[(struct array15_field_type *)array_39(D)].dim[_84].lbound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: def_stmt: _87 = MEM[(struct array15_field_type *)array_39(D)].dim[_84].ubound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: mark relevant 5, live 0: _87 = MEM[(struct array15_field_type *)array_39(D)].dim[_84].ubound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: def_stmt: _88 = MEM[(struct array15_field_type *)array_39(D)].dim[_84].lbound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: mark relevant 5, live 0: _88 = MEM[(struct array15_field_type *)array_39(D)].dim[_84].lbound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: worklist: examine stmt: _88 = MEM[(struct array15_field_type *)array_39(D)].dim[_84].lbound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: worklist: examine stmt: _87 = MEM[(struct array15_field_type *)array_39(D)].dim[_84].ubound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _268 = MEM[(struct array15_field_type &)array_39(D)].dim[_269].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: Detected single element interleaving MEM[(struct array15_field_type &)array_39(D)].dim[_269].stride step 24
gnu_opt_report.txt:field_mod.f90:1362:0: note: init: stmt relevant? _268 = MEM[(struct array15_field_type &)array_39(D)].dim[_269].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: def_stmt: _268 = MEM[(struct array15_field_type &)array_39(D)].dim[_269].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: mark relevant 5, live 0: _268 = MEM[(struct array15_field_type &)array_39(D)].dim[_269].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: worklist: examine stmt: _268 = MEM[(struct array15_field_type &)array_39(D)].dim[_269].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: ==> examining statement: _268 = MEM[(struct array15_field_type &)array_39(D)].dim[_269].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note:   based on:     _268 = MEM[(struct array15_field_type &)array_39(D)].dim[_269].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: can't force alignment of ref: MEM[(struct array15_field_type &)array_39(D)].dim[_269].stride
gnu_opt_report.txt:field_mod.f90:1362:0: note: ==> examining statement: _268 = MEM[(struct array15_field_type &)array_39(D)].dim[_269].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: vect_is_simple_use: operand MEM[(struct array15_field_type &)array_39(D)].dim[_269].stride
gnu_opt_report.txt:field_mod.f90:1362:0: note: vect_is_simple_use: operand MEM[(struct array15_field_type &)array_39(D)].dim[_269].stride
gnu_opt_report.txt:field_mod.f90:1362:0: note: def_stmt: _268 = MEM[(struct array15_field_type &)array_39(D)].dim[_269].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: pretmp_256 = MEM[(struct array15_field_type &)array_39(D)].dtype.rank;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access pretmp_256 = MEM[(struct array15_field_type &)array_39(D)].dtype.rank;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _245 = MEM[(struct array15_field_type &)array_39(D)].dim[_207].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _245 = MEM[(struct array15_field_type &)array_39(D)].dim[_207].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _186 = MEM[(struct array15_field_type &)array_39(D)].dim[_187].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _186 = MEM[(struct array15_field_type &)array_39(D)].dim[_187].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _180 = MEM[(struct array15_field_type &)array_39(D)].dim[_181].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _180 = MEM[(struct array15_field_type &)array_39(D)].dim[_181].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _174 = MEM[(struct array15_field_type &)array_39(D)].dim[_175].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _174 = MEM[(struct array15_field_type &)array_39(D)].dim[_175].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _168 = MEM[(struct array15_field_type &)array_39(D)].dim[_169].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _168 = MEM[(struct array15_field_type &)array_39(D)].dim[_169].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _162 = MEM[(struct array15_field_type &)array_39(D)].dim[_163].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _162 = MEM[(struct array15_field_type &)array_39(D)].dim[_163].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _156 = MEM[(struct array15_field_type &)array_39(D)].dim[_157].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _156 = MEM[(struct array15_field_type &)array_39(D)].dim[_157].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _148 = MEM[(struct array15_field_type &)array_39(D)].dim[_149].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _148 = MEM[(struct array15_field_type &)array_39(D)].dim[_149].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _118 = MEM[(struct array15_field_type &)array_39(D)].dim[_136].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _118 = MEM[(struct array15_field_type &)array_39(D)].dim[_136].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _34 = MEM[(struct array15_field_type &)array_39(D)].dim[_83].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _34 = MEM[(struct array15_field_type &)array_39(D)].dim[_83].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _28 = MEM[(struct array15_field_type &)array_39(D)].dim[_29].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _28 = MEM[(struct array15_field_type &)array_39(D)].dim[_29].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _296 = MEM[(struct array15_field_type &)array_39(D)].dim[_297].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _296 = MEM[(struct array15_field_type &)array_39(D)].dim[_297].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _281 = MEM[(struct array15_field_type &)array_39(D)].dim[_283].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _281 = MEM[(struct array15_field_type &)array_39(D)].dim[_283].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _240 = MEM[(struct array15_field_type &)array_39(D)].dim[_246].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _240 = MEM[(struct array15_field_type &)array_39(D)].dim[_246].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _58 = MEM[(struct array15_field_type &)array_39(D)].dim[_15].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _58 = MEM[(struct array15_field_type &)array_39(D)].dim[_15].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _75 = MEM[(struct array15_field_type &)array_39(D)].dim[_74].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _75 = MEM[(struct array15_field_type &)array_39(D)].dim[_74].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _268 = MEM[(struct array15_field_type &)array_39(D)].dim[_269].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: not consecutive access _268 = MEM[(struct array15_field_type &)array_39(D)].dim[_269].stride;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _87 = MEM[(struct array15_field_type *)array_39(D)].dim[_84].ubound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _88 = MEM[(struct array15_field_type *)array_39(D)].dim[_84].lbound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: Detected interleaving load MEM[(struct array15_field_type *)array_39(D)].dim[_84].lbound and MEM[(struct array15_field_type *)array_39(D)].dim[_84].ubound
gnu_opt_report.txt:field_mod.f90:1362:0: note: Detected interleaving load of size 2 starting with _88 = MEM[(struct array15_field_type *)array_39(D)].dim[_84].lbound;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: _111 = MEM[(struct array15_field_type &)array_39(D)].data;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: pretmp_294 = MEM[(struct array15_field_type &)array_39(D)].dtype.rank;
gnu_opt_report.txt:field_mod.f90:1362:0: note: got vectype for stmt: pretmp_257 = MEM[(struct array15_field_type &)array_39(D)].dtype.rank;
gnu_opt_report.txt:field_mod.f90:243:0: note: got vectype for stmt: self.field_type.halo.data = 0B;
gnu_opt_report.txt:field_mod.f90:243:0: note: got vectype for stmt: self.field_type.grid = grid_49(D);
gnu_opt_report.txt:field_mod.f90:243:0: note: got vectype for stmt: self.field_type.data_on_device = 0;
gnu_opt_report.txt:field_mod.f90:243:0: note: not consecutive access self.field_type.data_on_device = 0;
gnu_opt_report.txt:field_mod.f90:243:0: note: not consecutive access self.field_type.grid = grid_49(D);
gnu_opt_report.txt:field_mod.f90:243:0: note: not consecutive access self.field_type.halo.data = 0B;
gnu_opt_report.txt:field_mod.f90:317:0: note: got vectype for stmt: MEM[(struct field_type *)&self].defined_on = 0;
gnu_opt_report.txt:field_mod.f90:317:0: note: not consecutive access MEM[(struct field_type *)&self].defined_on = 0;
gnu_opt_report.txt:field_mod.f90:969:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstart = pretmp_1847;
gnu_opt_report.txt:field_mod.f90:969:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstop = pretmp_1848;
gnu_opt_report.txt:field_mod.f90:969:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystart = pretmp_1849;
gnu_opt_report.txt:field_mod.f90:969:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystop = pretmp_1850;
gnu_opt_report.txt:field_mod.f90:969:0: note: got vectype for stmt: MEM[(struct field_type *)&self].num_halos = 2;
gnu_opt_report.txt:field_mod.f90:969:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:969:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystart
gnu_opt_report.txt:field_mod.f90:969:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:969:0: note: Detected interleaving store of size 4 starting with MEM[(struct field_type *)&self].internal.xstart = pretmp_1847;
gnu_opt_report.txt:field_mod.f90:969:0: note: not consecutive access MEM[(struct field_type *)&self].num_halos = 2;
gnu_opt_report.txt:field_mod.f90:969:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstart = pretmp_1847;
gnu_opt_report.txt:field_mod.f90:969:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstop = pretmp_1848;
gnu_opt_report.txt:field_mod.f90:969:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystart = pretmp_1849;
gnu_opt_report.txt:field_mod.f90:969:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystop = pretmp_1850;
gnu_opt_report.txt:field_mod.f90:969:0: note: 	stmt 0 MEM[(struct field_type *)&self].internal.xstart = pretmp_1847;
gnu_opt_report.txt:field_mod.f90:969:0: note: 	stmt 1 MEM[(struct field_type *)&self].internal.xstop = pretmp_1848;
gnu_opt_report.txt:field_mod.f90:969:0: note: 	stmt 2 MEM[(struct field_type *)&self].internal.ystart = pretmp_1849;
gnu_opt_report.txt:field_mod.f90:969:0: note: 	stmt 3 MEM[(struct field_type *)&self].internal.ystop = pretmp_1850;
gnu_opt_report.txt:field_mod.f90:969:0: note:   based on:     MEM[(struct field_type *)&self].internal.xstart = pretmp_1847;
gnu_opt_report.txt:field_mod.f90:969:0: note: misalign = 8 bytes of ref MEM[(struct field_type *)&self].internal.xstart
gnu_opt_report.txt:field_mod.f90:969:0: note: ==> examining statement: MEM[(struct field_type *)&self].internal.xstart = pretmp_1847;
gnu_opt_report.txt:field_mod.f90:969:0: note: ------>vectorizing SLP node starting from: MEM[(struct field_type *)&self].internal.xstart = pretmp_1847;
gnu_opt_report.txt:field_mod.f90:969:0: note: create vector_type-pointer variable to type: vector(4) integer(kind=4)  vectorizing a pointer ref: MEM[(struct field_type *)&self].internal.xstart
gnu_opt_report.txt:field_mod.f90:969:0: note: created &MEM[(struct field_type *)&self].internal.xstart
gnu_opt_report.txt:field_mod.f90:967:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstart = _356;
gnu_opt_report.txt:field_mod.f90:967:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstop = pretmp_1848;
gnu_opt_report.txt:field_mod.f90:967:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystart = pretmp_1849;
gnu_opt_report.txt:field_mod.f90:967:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystop = pretmp_1850;
gnu_opt_report.txt:field_mod.f90:967:0: note: got vectype for stmt: MEM[(struct field_type *)&self].num_halos = 0;
gnu_opt_report.txt:field_mod.f90:967:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:967:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystart
gnu_opt_report.txt:field_mod.f90:967:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:967:0: note: Detected interleaving store of size 4 starting with MEM[(struct field_type *)&self].internal.xstart = _356;
gnu_opt_report.txt:field_mod.f90:967:0: note: not consecutive access MEM[(struct field_type *)&self].num_halos = 0;
gnu_opt_report.txt:field_mod.f90:967:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstart = _356;
gnu_opt_report.txt:field_mod.f90:967:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstop = pretmp_1848;
gnu_opt_report.txt:field_mod.f90:967:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystart = pretmp_1849;
gnu_opt_report.txt:field_mod.f90:967:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystop = pretmp_1850;
gnu_opt_report.txt:field_mod.f90:967:0: note:   based on:     MEM[(struct field_type *)&self].internal.xstart = _356;
gnu_opt_report.txt:field_mod.f90:972:0: note: got vectype for stmt: MEM[(struct field_type *)&self].num_halos = prephitmp_1852;
gnu_opt_report.txt:field_mod.f90:975:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dtype.elem_len = 52;
gnu_opt_report.txt:field_mod.f90:975:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dtype.rank = 1;
gnu_opt_report.txt:field_mod.f90:975:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dtype.type = 5;
gnu_opt_report.txt:field_mod.f90:975:0: note: Detected interleaving store MEM[(struct field_type *)&self].halo.dtype.rank and MEM[(struct field_type *)&self].halo.dtype.type
gnu_opt_report.txt:field_mod.f90:975:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].halo.dtype.rank = 1;
gnu_opt_report.txt:field_mod.f90:975:0: note: not consecutive access MEM[(struct field_type *)&self].halo.dtype.elem_len = 52;
gnu_opt_report.txt:field_mod.f90:975:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dtype.rank = 1;
gnu_opt_report.txt:field_mod.f90:975:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.data = _377;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dim[0].lbound = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dim[0].ubound = _382;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dim[0].stride = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.offset = -1;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving store MEM[(struct field_type *)&self].halo.span and MEM[(struct field_type *)&self].halo.dim[0].stride
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving store MEM[(struct field_type *)&self].halo.span and MEM[(struct field_type *)&self].halo.dim[0].lbound
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving store MEM[(struct field_type *)&self].halo.span and MEM[(struct field_type *)&self].halo.dim[0].ubound
gnu_opt_report.txt:field_mod.f90:978:0: note: not consecutive access MEM[(struct field_type *)&self].halo.offset = -1;
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving store of size 4 starting with MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dim[0].stride = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dim[0].lbound = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dim[0].ubound = _382;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP failed: different operation in stmt MEM[(struct field_type *)&self].halo.dim[0].ubound = _382;
gnu_opt_report.txt:field_mod.f90:978:0: note: original stmt MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dim[0].stride = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: 	stmt 0 MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: 	stmt 1 MEM[(struct field_type *)&self].halo.dim[0].stride = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note:   based on:     MEM[(struct field_type *)&self].halo.dim[0].lbound = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: misalign = 8 bytes of ref MEM[(struct field_type *)&self].halo.span
gnu_opt_report.txt:field_mod.f90:978:0: note: ==> examining statement: MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: ------>vectorizing SLP node starting from: MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: create vector_type-pointer variable to type: vector(2) integer(kind=8)  vectorizing a pointer ref: MEM[(struct field_type *)&self].halo.span
gnu_opt_report.txt:field_mod.f90:978:0: note: created &MEM[(struct field_type *)&self].halo.span
gnu_opt_report.txt:field_mod.f90:1004:0: note: got vectype for stmt: pretmp_1521 = MEM[(struct field_type *)&self].internal.ystop;
gnu_opt_report.txt:field_mod.f90:1004:0: note: got vectype for stmt: pretmp_1535 = MEM[(struct field_type *)&self].internal.ystart;
gnu_opt_report.txt:field_mod.f90:1004:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.ystart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:1004:0: note: Detected interleaving load of size 2 starting with pretmp_1535 = MEM[(struct field_type *)&self].internal.ystart;
gnu_opt_report.txt:field_mod.f90:1027:0: note: got vectype for stmt: pretmp_1522 = MEM[(struct field_type *)&self].internal.ystop;
gnu_opt_report.txt:field_mod.f90:1027:0: note: got vectype for stmt: pretmp_1536 = MEM[(struct field_type *)&self].internal.ystart;
gnu_opt_report.txt:field_mod.f90:1027:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.ystart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:1027:0: note: Detected interleaving load of size 2 starting with pretmp_1536 = MEM[(struct field_type *)&self].internal.ystart;
gnu_opt_report.txt:field_mod.f90:1027:0: note:   based on:     pretmp_1522 = MEM[(struct field_type *)&self].internal.ystop;
gnu_opt_report.txt:field_mod.f90:455:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstart = _407;
gnu_opt_report.txt:field_mod.f90:455:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstop = _409;
gnu_opt_report.txt:field_mod.f90:455:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:455:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].internal.xstart = _407;
gnu_opt_report.txt:field_mod.f90:455:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstart = _407;
gnu_opt_report.txt:field_mod.f90:455:0: note:   based on:     MEM[(struct field_type *)&self].internal.xstart = _407;
gnu_opt_report.txt:field_mod.f90:461:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystart = _413;
gnu_opt_report.txt:field_mod.f90:461:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystop = _414;
gnu_opt_report.txt:field_mod.f90:461:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.ystart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:461:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].internal.ystart = _413;
gnu_opt_report.txt:field_mod.f90:461:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystart = _413;
gnu_opt_report.txt:field_mod.f90:461:0: note:   based on:     MEM[(struct field_type *)&self].internal.ystart = _413;
gnu_opt_report.txt:field_mod.f90:463:0: note: got vectype for stmt: pretmp_1840 = MEM[(struct field_type *)&self].internal.ystop;
gnu_opt_report.txt:field_mod.f90:463:0: note: got vectype for stmt: pretmp_1842 = MEM[(struct field_type *)&self].internal.ystart;
gnu_opt_report.txt:field_mod.f90:463:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.ystart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:463:0: note: Detected interleaving load of size 2 starting with pretmp_1842 = MEM[(struct field_type *)&self].internal.ystart;
gnu_opt_report.txt:field_mod.f90:467:0: note: got vectype for stmt: MEM[(struct field_type *)&self].num_halos = 0;
gnu_opt_report.txt:field_mod.f90:467:0: note: got vectype for stmt: pretmp_1484 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:467:0: note: got vectype for stmt: pretmp_1498 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:467:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:467:0: note: Detected interleaving load of size 2 starting with pretmp_1498 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:467:0: note: not consecutive access MEM[(struct field_type *)&self].num_halos = 0;
gnu_opt_report.txt:field_mod.f90:317:0: note: got vectype for stmt: pretmp_1495 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:317:0: note: got vectype for stmt: pretmp_1509 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:317:0: note: got vectype for stmt: pretmp_1523 = MEM[(struct field_type *)&self].internal.ystop;
gnu_opt_report.txt:field_mod.f90:317:0: note: got vectype for stmt: pretmp_1537 = MEM[(struct field_type *)&self].internal.ystart;
gnu_opt_report.txt:field_mod.f90:317:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:317:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystart
gnu_opt_report.txt:field_mod.f90:317:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:317:0: note: Detected interleaving load of size 4 starting with pretmp_1509 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:488:0: note: got vectype for stmt: MEM[(struct field_type *)&self].defined_on = 1;
gnu_opt_report.txt:field_mod.f90:488:0: note: not consecutive access MEM[(struct field_type *)&self].defined_on = 1;
gnu_opt_report.txt:field_mod.f90:509:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstart = pretmp_1798;
gnu_opt_report.txt:field_mod.f90:509:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstop = pretmp_1799;
gnu_opt_report.txt:field_mod.f90:509:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystart = pretmp_1796;
gnu_opt_report.txt:field_mod.f90:509:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystop = pretmp_1797;
gnu_opt_report.txt:field_mod.f90:509:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:509:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystart
gnu_opt_report.txt:field_mod.f90:509:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:509:0: note: Detected interleaving store of size 4 starting with MEM[(struct field_type *)&self].internal.xstart = pretmp_1798;
gnu_opt_report.txt:field_mod.f90:509:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstart = pretmp_1798;
gnu_opt_report.txt:field_mod.f90:509:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstop = pretmp_1799;
gnu_opt_report.txt:field_mod.f90:509:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystart = pretmp_1796;
gnu_opt_report.txt:field_mod.f90:509:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystop = pretmp_1797;
gnu_opt_report.txt:field_mod.f90:509:0: note: 	stmt 0 MEM[(struct field_type *)&self].internal.xstart = pretmp_1798;
gnu_opt_report.txt:field_mod.f90:509:0: note: 	stmt 1 MEM[(struct field_type *)&self].internal.xstop = pretmp_1799;
gnu_opt_report.txt:field_mod.f90:509:0: note: 	stmt 2 MEM[(struct field_type *)&self].internal.ystart = pretmp_1796;
gnu_opt_report.txt:field_mod.f90:509:0: note: 	stmt 3 MEM[(struct field_type *)&self].internal.ystop = pretmp_1797;
gnu_opt_report.txt:field_mod.f90:509:0: note:   based on:     MEM[(struct field_type *)&self].internal.xstart = pretmp_1798;
gnu_opt_report.txt:field_mod.f90:509:0: note: misalign = 8 bytes of ref MEM[(struct field_type *)&self].internal.xstart
gnu_opt_report.txt:field_mod.f90:509:0: note: ==> examining statement: MEM[(struct field_type *)&self].internal.xstart = pretmp_1798;
gnu_opt_report.txt:field_mod.f90:509:0: note: ------>vectorizing SLP node starting from: MEM[(struct field_type *)&self].internal.xstart = pretmp_1798;
gnu_opt_report.txt:field_mod.f90:509:0: note: create vector_type-pointer variable to type: vector(4) integer(kind=4)  vectorizing a pointer ref: MEM[(struct field_type *)&self].internal.xstart
gnu_opt_report.txt:field_mod.f90:509:0: note: created &MEM[(struct field_type *)&self].internal.xstart
gnu_opt_report.txt:field_mod.f90:527:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstart = pretmp_1798;
gnu_opt_report.txt:field_mod.f90:527:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstop = pretmp_1799;
gnu_opt_report.txt:field_mod.f90:527:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystart = _429;
gnu_opt_report.txt:field_mod.f90:527:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystop = pretmp_1797;
gnu_opt_report.txt:field_mod.f90:527:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:527:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystart
gnu_opt_report.txt:field_mod.f90:527:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:527:0: note: Detected interleaving store of size 4 starting with MEM[(struct field_type *)&self].internal.xstart = pretmp_1798;
gnu_opt_report.txt:field_mod.f90:527:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstart = pretmp_1798;
gnu_opt_report.txt:field_mod.f90:527:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstop = pretmp_1799;
gnu_opt_report.txt:field_mod.f90:527:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystart = _429;
gnu_opt_report.txt:field_mod.f90:527:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystop = pretmp_1797;
gnu_opt_report.txt:field_mod.f90:527:0: note:   based on:     MEM[(struct field_type *)&self].internal.xstart = pretmp_1798;
gnu_opt_report.txt:field_mod.f90:968:0: note: got vectype for stmt: MEM[(struct field_type *)&self].num_halos = 0;
gnu_opt_report.txt:field_mod.f90:968:0: note: not consecutive access MEM[(struct field_type *)&self].num_halos = 0;
gnu_opt_report.txt:field_mod.f90:969:0: note: got vectype for stmt: MEM[(struct field_type *)&self].num_halos = 2;
gnu_opt_report.txt:field_mod.f90:972:0: note: got vectype for stmt: MEM[(struct field_type *)&self].num_halos = prephitmp_1807;
gnu_opt_report.txt:field_mod.f90:975:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dtype.elem_len = 52;
gnu_opt_report.txt:field_mod.f90:975:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dtype.rank = 1;
gnu_opt_report.txt:field_mod.f90:975:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dtype.type = 5;
gnu_opt_report.txt:field_mod.f90:975:0: note: Detected interleaving store MEM[(struct field_type *)&self].halo.dtype.rank and MEM[(struct field_type *)&self].halo.dtype.type
gnu_opt_report.txt:field_mod.f90:975:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].halo.dtype.rank = 1;
gnu_opt_report.txt:field_mod.f90:975:0: note: not consecutive access MEM[(struct field_type *)&self].halo.dtype.elem_len = 52;
gnu_opt_report.txt:field_mod.f90:975:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dtype.rank = 1;
gnu_opt_report.txt:field_mod.f90:975:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.data = _448;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dim[0].lbound = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dim[0].ubound = _453;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dim[0].stride = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.offset = -1;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving store MEM[(struct field_type *)&self].halo.span and MEM[(struct field_type *)&self].halo.dim[0].stride
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving store MEM[(struct field_type *)&self].halo.span and MEM[(struct field_type *)&self].halo.dim[0].lbound
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving store MEM[(struct field_type *)&self].halo.span and MEM[(struct field_type *)&self].halo.dim[0].ubound
gnu_opt_report.txt:field_mod.f90:978:0: note: not consecutive access MEM[(struct field_type *)&self].halo.offset = -1;
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving store of size 4 starting with MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dim[0].stride = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dim[0].lbound = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dim[0].ubound = _453;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP failed: different operation in stmt MEM[(struct field_type *)&self].halo.dim[0].ubound = _453;
gnu_opt_report.txt:field_mod.f90:978:0: note: original stmt MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dim[0].stride = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: 	stmt 0 MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: 	stmt 1 MEM[(struct field_type *)&self].halo.dim[0].stride = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note:   based on:     MEM[(struct field_type *)&self].halo.dim[0].lbound = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: misalign = 8 bytes of ref MEM[(struct field_type *)&self].halo.span
gnu_opt_report.txt:field_mod.f90:978:0: note: ==> examining statement: MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: ------>vectorizing SLP node starting from: MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: create vector_type-pointer variable to type: vector(2) integer(kind=8)  vectorizing a pointer ref: MEM[(struct field_type *)&self].halo.span
gnu_opt_report.txt:field_mod.f90:978:0: note: created &MEM[(struct field_type *)&self].halo.span
gnu_opt_report.txt:field_mod.f90:589:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstart = _478;
gnu_opt_report.txt:field_mod.f90:589:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstop = _479;
gnu_opt_report.txt:field_mod.f90:589:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:589:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].internal.xstart = _478;
gnu_opt_report.txt:field_mod.f90:589:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstart = _478;
gnu_opt_report.txt:field_mod.f90:589:0: note:   based on:     MEM[(struct field_type *)&self].internal.xstart = _478;
gnu_opt_report.txt:field_mod.f90:596:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystart = _483;
gnu_opt_report.txt:field_mod.f90:596:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystop = _485;
gnu_opt_report.txt:field_mod.f90:596:0: note: got vectype for stmt: pretmp_1493 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:596:0: note: got vectype for stmt: pretmp_1507 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:596:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:596:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.ystart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:596:0: note: Detected interleaving load of size 2 starting with pretmp_1507 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:596:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].internal.ystart = _483;
gnu_opt_report.txt:field_mod.f90:596:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystart = _483;
gnu_opt_report.txt:field_mod.f90:596:0: note:   based on:     MEM[(struct field_type *)&self].internal.ystart = _483;
gnu_opt_report.txt:field_mod.f90:598:0: note: got vectype for stmt: pretmp_1485 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:598:0: note: got vectype for stmt: pretmp_1499 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:598:0: note: got vectype for stmt: pretmp_1513 = MEM[(struct field_type *)&self].internal.ystop;
gnu_opt_report.txt:field_mod.f90:598:0: note: got vectype for stmt: pretmp_1527 = MEM[(struct field_type *)&self].internal.ystart;
gnu_opt_report.txt:field_mod.f90:598:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:598:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystart
gnu_opt_report.txt:field_mod.f90:598:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:598:0: note: Detected interleaving load of size 4 starting with pretmp_1499 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:488:0: note: got vectype for stmt: pretmp_1492 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:488:0: note: got vectype for stmt: pretmp_1506 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:488:0: note: got vectype for stmt: pretmp_1520 = MEM[(struct field_type *)&self].internal.ystop;
gnu_opt_report.txt:field_mod.f90:488:0: note: got vectype for stmt: pretmp_1534 = MEM[(struct field_type *)&self].internal.ystart;
gnu_opt_report.txt:field_mod.f90:488:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:488:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystart
gnu_opt_report.txt:field_mod.f90:488:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:488:0: note: Detected interleaving load of size 4 starting with pretmp_1506 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:620:0: note: got vectype for stmt: MEM[(struct field_type *)&self].defined_on = 2;
gnu_opt_report.txt:field_mod.f90:620:0: note: not consecutive access MEM[(struct field_type *)&self].defined_on = 2;
gnu_opt_report.txt:field_mod.f90:968:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstart = _491;
gnu_opt_report.txt:field_mod.f90:968:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstop = _492;
gnu_opt_report.txt:field_mod.f90:968:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystart = _493;
gnu_opt_report.txt:field_mod.f90:968:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystop = _494;
gnu_opt_report.txt:field_mod.f90:968:0: note: got vectype for stmt: MEM[(struct field_type *)&self].num_halos = 0;
gnu_opt_report.txt:field_mod.f90:968:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:968:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystart
gnu_opt_report.txt:field_mod.f90:968:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:968:0: note: Detected interleaving store of size 4 starting with MEM[(struct field_type *)&self].internal.xstart = _491;
gnu_opt_report.txt:field_mod.f90:968:0: note: not consecutive access MEM[(struct field_type *)&self].num_halos = 0;
gnu_opt_report.txt:field_mod.f90:968:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstart = _491;
gnu_opt_report.txt:field_mod.f90:968:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstop = _492;
gnu_opt_report.txt:field_mod.f90:968:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystart = _493;
gnu_opt_report.txt:field_mod.f90:968:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystop = _494;
gnu_opt_report.txt:field_mod.f90:968:0: note: 	stmt 0 MEM[(struct field_type *)&self].internal.xstart = _491;
gnu_opt_report.txt:field_mod.f90:968:0: note: 	stmt 1 MEM[(struct field_type *)&self].internal.xstop = _492;
gnu_opt_report.txt:field_mod.f90:968:0: note: 	stmt 2 MEM[(struct field_type *)&self].internal.ystart = _493;
gnu_opt_report.txt:field_mod.f90:968:0: note: 	stmt 3 MEM[(struct field_type *)&self].internal.ystop = _494;
gnu_opt_report.txt:field_mod.f90:968:0: note:   based on:     MEM[(struct field_type *)&self].internal.xstart = _491;
gnu_opt_report.txt:field_mod.f90:968:0: note: misalign = 8 bytes of ref MEM[(struct field_type *)&self].internal.xstart
gnu_opt_report.txt:field_mod.f90:968:0: note: ==> examining statement: MEM[(struct field_type *)&self].internal.xstart = _491;
gnu_opt_report.txt:field_mod.f90:968:0: note: ------>vectorizing SLP node starting from: MEM[(struct field_type *)&self].internal.xstart = _491;
gnu_opt_report.txt:field_mod.f90:968:0: note: create vector_type-pointer variable to type: vector(4) integer(kind=4)  vectorizing a pointer ref: MEM[(struct field_type *)&self].internal.xstart
gnu_opt_report.txt:field_mod.f90:968:0: note: created &MEM[(struct field_type *)&self].internal.xstart
gnu_opt_report.txt:field_mod.f90:969:0: note: got vectype for stmt: MEM[(struct field_type *)&self].num_halos = 2;
gnu_opt_report.txt:field_mod.f90:972:0: note: got vectype for stmt: MEM[(struct field_type *)&self].num_halos = prephitmp_1768;
gnu_opt_report.txt:field_mod.f90:975:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dtype.elem_len = 52;
gnu_opt_report.txt:field_mod.f90:975:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dtype.rank = 1;
gnu_opt_report.txt:field_mod.f90:975:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dtype.type = 5;
gnu_opt_report.txt:field_mod.f90:975:0: note: Detected interleaving store MEM[(struct field_type *)&self].halo.dtype.rank and MEM[(struct field_type *)&self].halo.dtype.type
gnu_opt_report.txt:field_mod.f90:975:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].halo.dtype.rank = 1;
gnu_opt_report.txt:field_mod.f90:975:0: note: not consecutive access MEM[(struct field_type *)&self].halo.dtype.elem_len = 52;
gnu_opt_report.txt:field_mod.f90:975:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dtype.rank = 1;
gnu_opt_report.txt:field_mod.f90:975:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.data = _512;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dim[0].lbound = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dim[0].ubound = _517;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dim[0].stride = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.offset = -1;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving store MEM[(struct field_type *)&self].halo.span and MEM[(struct field_type *)&self].halo.dim[0].stride
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving store MEM[(struct field_type *)&self].halo.span and MEM[(struct field_type *)&self].halo.dim[0].lbound
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving store MEM[(struct field_type *)&self].halo.span and MEM[(struct field_type *)&self].halo.dim[0].ubound
gnu_opt_report.txt:field_mod.f90:978:0: note: not consecutive access MEM[(struct field_type *)&self].halo.offset = -1;
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving store of size 4 starting with MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dim[0].stride = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dim[0].lbound = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dim[0].ubound = _517;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP failed: different operation in stmt MEM[(struct field_type *)&self].halo.dim[0].ubound = _517;
gnu_opt_report.txt:field_mod.f90:978:0: note: original stmt MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dim[0].stride = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: 	stmt 0 MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: 	stmt 1 MEM[(struct field_type *)&self].halo.dim[0].stride = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note:   based on:     MEM[(struct field_type *)&self].halo.dim[0].lbound = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: misalign = 8 bytes of ref MEM[(struct field_type *)&self].halo.span
gnu_opt_report.txt:field_mod.f90:978:0: note: ==> examining statement: MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: ------>vectorizing SLP node starting from: MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: create vector_type-pointer variable to type: vector(2) integer(kind=8)  vectorizing a pointer ref: MEM[(struct field_type *)&self].halo.span
gnu_opt_report.txt:field_mod.f90:978:0: note: created &MEM[(struct field_type *)&self].halo.span
gnu_opt_report.txt:field_mod.f90:692:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstart = _542;
gnu_opt_report.txt:field_mod.f90:692:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstop = _543;
gnu_opt_report.txt:field_mod.f90:692:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:692:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].internal.xstart = _542;
gnu_opt_report.txt:field_mod.f90:692:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstart = _542;
gnu_opt_report.txt:field_mod.f90:692:0: note:   based on:     MEM[(struct field_type *)&self].internal.xstart = _542;
gnu_opt_report.txt:field_mod.f90:701:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystart = _547;
gnu_opt_report.txt:field_mod.f90:701:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystop = _548;
gnu_opt_report.txt:field_mod.f90:701:0: note: got vectype for stmt: pretmp_1490 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:701:0: note: got vectype for stmt: pretmp_1504 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:701:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:701:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.ystart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:701:0: note: Detected interleaving load of size 2 starting with pretmp_1504 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:701:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].internal.ystart = _547;
gnu_opt_report.txt:field_mod.f90:701:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystart = _547;
gnu_opt_report.txt:field_mod.f90:701:0: note:   based on:     MEM[(struct field_type *)&self].internal.ystart = _547;
gnu_opt_report.txt:field_mod.f90:703:0: note: got vectype for stmt: pretmp_1486 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:703:0: note: got vectype for stmt: pretmp_1500 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:703:0: note: got vectype for stmt: pretmp_1514 = MEM[(struct field_type *)&self].internal.ystop;
gnu_opt_report.txt:field_mod.f90:703:0: note: got vectype for stmt: pretmp_1528 = MEM[(struct field_type *)&self].internal.ystart;
gnu_opt_report.txt:field_mod.f90:703:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:703:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystart
gnu_opt_report.txt:field_mod.f90:703:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:703:0: note: Detected interleaving load of size 4 starting with pretmp_1500 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:620:0: note: got vectype for stmt: pretmp_1489 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:620:0: note: got vectype for stmt: pretmp_1503 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:620:0: note: got vectype for stmt: pretmp_1518 = MEM[(struct field_type *)&self].internal.ystop;
gnu_opt_report.txt:field_mod.f90:620:0: note: got vectype for stmt: pretmp_1532 = MEM[(struct field_type *)&self].internal.ystart;
gnu_opt_report.txt:field_mod.f90:620:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:620:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystart
gnu_opt_report.txt:field_mod.f90:620:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:620:0: note: Detected interleaving load of size 4 starting with pretmp_1503 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:725:0: note: got vectype for stmt: MEM[(struct field_type *)&self].defined_on = 3;
gnu_opt_report.txt:field_mod.f90:725:0: note: not consecutive access MEM[(struct field_type *)&self].defined_on = 3;
gnu_opt_report.txt:field_mod.f90:748:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstart = pretmp_1717;
gnu_opt_report.txt:field_mod.f90:748:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstop = _558;
gnu_opt_report.txt:field_mod.f90:748:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:748:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].internal.xstart = pretmp_1717;
gnu_opt_report.txt:field_mod.f90:748:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstart = pretmp_1717;
gnu_opt_report.txt:field_mod.f90:748:0: note:   based on:     MEM[(struct field_type *)&self].internal.xstart = pretmp_1717;
gnu_opt_report.txt:field_mod.f90:754:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstart = _560;
gnu_opt_report.txt:field_mod.f90:754:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstop = _561;
gnu_opt_report.txt:field_mod.f90:754:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:754:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].internal.xstart = _560;
gnu_opt_report.txt:field_mod.f90:754:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstart = _560;
gnu_opt_report.txt:field_mod.f90:754:0: note:   based on:     MEM[(struct field_type *)&self].internal.xstart = _560;
gnu_opt_report.txt:field_mod.f90:759:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystart = pretmp_1731;
gnu_opt_report.txt:field_mod.f90:759:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystop = _568;
gnu_opt_report.txt:field_mod.f90:759:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.ystart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:759:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].internal.ystart = pretmp_1731;
gnu_opt_report.txt:field_mod.f90:759:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystart = pretmp_1731;
gnu_opt_report.txt:field_mod.f90:759:0: note:   based on:     MEM[(struct field_type *)&self].internal.ystart = pretmp_1731;
gnu_opt_report.txt:field_mod.f90:765:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystart = _570;
gnu_opt_report.txt:field_mod.f90:765:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystop = _571;
gnu_opt_report.txt:field_mod.f90:765:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.ystart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:765:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].internal.ystart = _570;
gnu_opt_report.txt:field_mod.f90:765:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystart = _570;
gnu_opt_report.txt:field_mod.f90:765:0: note:   based on:     MEM[(struct field_type *)&self].internal.ystart = _570;
gnu_opt_report.txt:field_mod.f90:968:0: note: got vectype for stmt: MEM[(struct field_type *)&self].num_halos = 0;
gnu_opt_report.txt:field_mod.f90:968:0: note: not consecutive access MEM[(struct field_type *)&self].num_halos = 0;
gnu_opt_report.txt:field_mod.f90:969:0: note: got vectype for stmt: MEM[(struct field_type *)&self].num_halos = 2;
gnu_opt_report.txt:field_mod.f90:972:0: note: got vectype for stmt: MEM[(struct field_type *)&self].num_halos = prephitmp_1739;
gnu_opt_report.txt:field_mod.f90:975:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dtype.elem_len = 52;
gnu_opt_report.txt:field_mod.f90:975:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dtype.rank = 1;
gnu_opt_report.txt:field_mod.f90:975:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dtype.type = 5;
gnu_opt_report.txt:field_mod.f90:975:0: note: Detected interleaving store MEM[(struct field_type *)&self].halo.dtype.rank and MEM[(struct field_type *)&self].halo.dtype.type
gnu_opt_report.txt:field_mod.f90:975:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].halo.dtype.rank = 1;
gnu_opt_report.txt:field_mod.f90:975:0: note: not consecutive access MEM[(struct field_type *)&self].halo.dtype.elem_len = 52;
gnu_opt_report.txt:field_mod.f90:975:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dtype.rank = 1;
gnu_opt_report.txt:field_mod.f90:975:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.data = _589;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dim[0].lbound = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dim[0].ubound = _594;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.dim[0].stride = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.offset = -1;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: pretmp_1750 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:978:0: note: got vectype for stmt: pretmp_1752 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving store MEM[(struct field_type *)&self].halo.span and MEM[(struct field_type *)&self].halo.dim[0].stride
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving store MEM[(struct field_type *)&self].halo.span and MEM[(struct field_type *)&self].halo.dim[0].lbound
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving store MEM[(struct field_type *)&self].halo.span and MEM[(struct field_type *)&self].halo.dim[0].ubound
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving load of size 2 starting with pretmp_1752 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:978:0: note: not consecutive access MEM[(struct field_type *)&self].halo.offset = -1;
gnu_opt_report.txt:field_mod.f90:978:0: note: Detected interleaving store of size 4 starting with MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dim[0].stride = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dim[0].lbound = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dim[0].ubound = _594;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP failed: different operation in stmt MEM[(struct field_type *)&self].halo.dim[0].ubound = _594;
gnu_opt_report.txt:field_mod.f90:978:0: note: original stmt MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: Build SLP for MEM[(struct field_type *)&self].halo.dim[0].stride = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: 	stmt 0 MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: 	stmt 1 MEM[(struct field_type *)&self].halo.dim[0].stride = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note:   based on:     MEM[(struct field_type *)&self].halo.dim[0].lbound = 1;
gnu_opt_report.txt:field_mod.f90:978:0: note: misalign = 8 bytes of ref MEM[(struct field_type *)&self].halo.span
gnu_opt_report.txt:field_mod.f90:978:0: note: ==> examining statement: MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: ------>vectorizing SLP node starting from: MEM[(struct field_type *)&self].halo.span = 52;
gnu_opt_report.txt:field_mod.f90:978:0: note: create vector_type-pointer variable to type: vector(2) integer(kind=8)  vectorizing a pointer ref: MEM[(struct field_type *)&self].halo.span
gnu_opt_report.txt:field_mod.f90:978:0: note: created &MEM[(struct field_type *)&self].halo.span
gnu_opt_report.txt:field_mod.f90:1001:0: note: def_stmt: pretmp_1752 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:1001:0: note: def_stmt: pretmp_1752 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:1001:0: note: def_stmt: pretmp_1750 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:1001:0: note: def_stmt: pretmp_1750 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:1001:0: note: def_stmt: pretmp_1752 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:1001:0: note: def_stmt: pretmp_1752 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:1001:0: note: def_stmt: pretmp_1750 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:1001:0: note: def_stmt: pretmp_1750 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:1001:0: note: def_stmt: pretmp_1752 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:1001:0: note: def_stmt: pretmp_1750 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:1001:0: note: def_stmt: pretmp_1752 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:1001:0: note: def_stmt: pretmp_1752 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:1001:0: note: def_stmt: pretmp_1750 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:1001:0: note: def_stmt: pretmp_1750 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:821:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstart = _619;
gnu_opt_report.txt:field_mod.f90:821:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstop = _621;
gnu_opt_report.txt:field_mod.f90:821:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:821:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].internal.xstart = _619;
gnu_opt_report.txt:field_mod.f90:821:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstart = _619;
gnu_opt_report.txt:field_mod.f90:821:0: note:   based on:     MEM[(struct field_type *)&self].internal.xstart = _619;
gnu_opt_report.txt:field_mod.f90:823:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystart = _623;
gnu_opt_report.txt:field_mod.f90:823:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystop = _625;
gnu_opt_report.txt:field_mod.f90:823:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.ystart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:823:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].internal.ystart = _623;
gnu_opt_report.txt:field_mod.f90:823:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystart = _623;
gnu_opt_report.txt:field_mod.f90:823:0: note:   based on:     MEM[(struct field_type *)&self].internal.ystart = _623;
gnu_opt_report.txt:field_mod.f90:825:0: note: got vectype for stmt: pretmp_1515 = MEM[(struct field_type *)&self].internal.ystop;
gnu_opt_report.txt:field_mod.f90:825:0: note: got vectype for stmt: pretmp_1529 = MEM[(struct field_type *)&self].internal.ystart;
gnu_opt_report.txt:field_mod.f90:825:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.ystart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:825:0: note: Detected interleaving load of size 2 starting with pretmp_1529 = MEM[(struct field_type *)&self].internal.ystart;
gnu_opt_report.txt:field_mod.f90:725:0: note: got vectype for stmt: pretmp_1488 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:725:0: note: got vectype for stmt: pretmp_1502 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:725:0: note: got vectype for stmt: pretmp_1517 = MEM[(struct field_type *)&self].internal.ystop;
gnu_opt_report.txt:field_mod.f90:725:0: note: got vectype for stmt: pretmp_1531 = MEM[(struct field_type *)&self].internal.ystart;
gnu_opt_report.txt:field_mod.f90:725:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:725:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystart
gnu_opt_report.txt:field_mod.f90:725:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:725:0: note: Detected interleaving load of size 4 starting with pretmp_1502 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:296:0: note: got vectype for stmt: MEM[(struct field_type *)&self].defined_on = 4;
gnu_opt_report.txt:field_mod.f90:296:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstart = 1;
gnu_opt_report.txt:field_mod.f90:296:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.xstop = m_316;
gnu_opt_report.txt:field_mod.f90:296:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystart = 1;
gnu_opt_report.txt:field_mod.f90:296:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ystop = n_317;
gnu_opt_report.txt:field_mod.f90:296:0: note: got vectype for stmt: MEM[(struct field_type *)&self].num_halos = 0;
gnu_opt_report.txt:field_mod.f90:296:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:296:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystart
gnu_opt_report.txt:field_mod.f90:296:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:296:0: note: not consecutive access MEM[(struct field_type *)&self].defined_on = 4;
gnu_opt_report.txt:field_mod.f90:296:0: note: Detected interleaving store of size 4 starting with MEM[(struct field_type *)&self].internal.xstart = 1;
gnu_opt_report.txt:field_mod.f90:296:0: note: not consecutive access MEM[(struct field_type *)&self].num_halos = 0;
gnu_opt_report.txt:field_mod.f90:296:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstart = 1;
gnu_opt_report.txt:field_mod.f90:296:0: note: Build SLP for MEM[(struct field_type *)&self].internal.xstop = m_316;
gnu_opt_report.txt:field_mod.f90:296:0: note: Build SLP failed: different operation in stmt MEM[(struct field_type *)&self].internal.xstop = m_316;
gnu_opt_report.txt:field_mod.f90:296:0: note: original stmt MEM[(struct field_type *)&self].internal.xstart = 1;
gnu_opt_report.txt:field_mod.f90:296:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystart = 1;
gnu_opt_report.txt:field_mod.f90:296:0: note: Build SLP for MEM[(struct field_type *)&self].internal.ystop = n_317;
gnu_opt_report.txt:field_mod.f90:296:0: note: Build SLP failed: different operation in stmt MEM[(struct field_type *)&self].internal.ystop = n_317;
gnu_opt_report.txt:field_mod.f90:296:0: note: original stmt MEM[(struct field_type *)&self].internal.xstart = 1;
gnu_opt_report.txt:field_mod.f90:296:0: note:   based on:     MEM[(struct field_type *)&self].defined_on = 4;
gnu_opt_report.txt:field_mod.f90:243:0: note: got vectype for stmt: pretmp_1487 = MEM[(struct field_type *)&self].internal.xstop;
gnu_opt_report.txt:field_mod.f90:243:0: note: got vectype for stmt: pretmp_1501 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:243:0: note: got vectype for stmt: pretmp_1516 = MEM[(struct field_type *)&self].internal.ystop;
gnu_opt_report.txt:field_mod.f90:243:0: note: got vectype for stmt: pretmp_1530 = MEM[(struct field_type *)&self].internal.ystart;
gnu_opt_report.txt:field_mod.f90:243:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.xstop
gnu_opt_report.txt:field_mod.f90:243:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystart
gnu_opt_report.txt:field_mod.f90:243:0: note: Detected interleaving load MEM[(struct field_type *)&self].internal.xstart and MEM[(struct field_type *)&self].internal.ystop
gnu_opt_report.txt:field_mod.f90:243:0: note: Detected interleaving load of size 4 starting with pretmp_1501 = MEM[(struct field_type *)&self].internal.xstart;
gnu_opt_report.txt:field_mod.f90:1340:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.nx = _322;
gnu_opt_report.txt:field_mod.f90:1340:0: note: got vectype for stmt: MEM[(struct field_type *)&self].internal.ny = _326;
gnu_opt_report.txt:field_mod.f90:1340:0: note: got vectype for stmt: MEM[(struct field_type *)&self].whole.xstop = prephitmp_1587;
gnu_opt_report.txt:field_mod.f90:1340:0: note: got vectype for stmt: MEM[(struct field_type *)&self].whole.xstart = prephitmp_1571;
gnu_opt_report.txt:field_mod.f90:1340:0: note: got vectype for stmt: MEM[(struct field_type *)&self].whole.ystop = prephitmp_1633;
gnu_opt_report.txt:field_mod.f90:1340:0: note: got vectype for stmt: MEM[(struct field_type *)&self].whole.ystart = prephitmp_1616;
gnu_opt_report.txt:field_mod.f90:1340:0: note: got vectype for stmt: MEM[(struct field_type *)&self].whole.nx = _342;
gnu_opt_report.txt:field_mod.f90:1340:0: note: got vectype for stmt: MEM[(struct field_type *)&self].whole.ny = _346;
gnu_opt_report.txt:field_mod.f90:1340:0: note: Detected interleaving store MEM[(struct field_type *)&self].internal.nx and MEM[(struct field_type *)&self].internal.ny
gnu_opt_report.txt:field_mod.f90:1340:0: note: Detected interleaving store MEM[(struct field_type *)&self].whole.nx and MEM[(struct field_type *)&self].whole.ny
gnu_opt_report.txt:field_mod.f90:1340:0: note: Detected interleaving store MEM[(struct field_type *)&self].whole.nx and MEM[(struct field_type *)&self].whole.xstart
gnu_opt_report.txt:field_mod.f90:1340:0: note: Detected interleaving store MEM[(struct field_type *)&self].whole.nx and MEM[(struct field_type *)&self].whole.xstop
gnu_opt_report.txt:field_mod.f90:1340:0: note: Detected interleaving store MEM[(struct field_type *)&self].whole.nx and MEM[(struct field_type *)&self].whole.ystart
gnu_opt_report.txt:field_mod.f90:1340:0: note: Detected interleaving store MEM[(struct field_type *)&self].whole.nx and MEM[(struct field_type *)&self].whole.ystop
gnu_opt_report.txt:field_mod.f90:1340:0: note: Detected interleaving store of size 2 starting with MEM[(struct field_type *)&self].internal.nx = _322;
gnu_opt_report.txt:field_mod.f90:1340:0: note: Detected interleaving store of size 6 starting with MEM[(struct field_type *)&self].whole.nx = _342;
gnu_opt_report.txt:field_mod.f90:1340:0: note: Build SLP for MEM[(struct field_type *)&self].internal.nx = _322;
gnu_opt_report.txt:field_mod.f90:1340:0: note: Build SLP for MEM[(struct field_type *)&self].whole.nx = _342;
gnu_opt_report.txt:field_mod.f90:1340:0: note: Build SLP for MEM[(struct field_type *)&self].whole.ny = _346;
gnu_opt_report.txt:field_mod.f90:1340:0: note: Build SLP for MEM[(struct field_type *)&self].whole.xstart = prephitmp_1571;
gnu_opt_report.txt:field_mod.f90:1340:0: note: Build SLP for MEM[(struct field_type *)&self].whole.xstop = prephitmp_1587;
gnu_opt_report.txt:field_mod.f90:1340:0: note: Build SLP for MEM[(struct field_type *)&self].whole.ystart = prephitmp_1616;
gnu_opt_report.txt:field_mod.f90:1340:0: note: Build SLP for MEM[(struct field_type *)&self].whole.ystop = prephitmp_1633;
gnu_opt_report.txt:field_mod.f90:1340:0: note:   based on:     MEM[(struct field_type *)&self].internal.nx = _322;
gnu_opt_report.txt:field_mod.f90:1202:0: note: got vectype for stmt: pretmp_1706 = self.field_type.grid;
gnu_opt_report.txt:field_mod.f90:1202:0: note: not consecutive access pretmp_1706 = self.field_type.grid;
grep: input file r2d_check.txt is also the output
grep: wq: No such file or directory
